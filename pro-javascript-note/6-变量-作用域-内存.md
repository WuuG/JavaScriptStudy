# 原始值与引用值
原始值：简单数据。按值访问
引用值：多个值都成的对象。按引用访问
## 动态属性
只有引用值可以动态添加属性
``` js
let obj = new Object()
obj.name = 'wuug'
console.log(obj); // {name:'wuug'}

let userName = "Nico"
userName.name = "steve" //不能添加，为什么不报错呢？
console.log(userName.name); //undefined
```
原始类型可以使用字面量形式初始化，也可以使用new进行初始化。但是new初始化会创建一个object类型的实例
``` js
let name1 = 'Nico'
let name2 = new String('Steve')
name1.age = 15
name2.age = 18
console.log(name1); // Nico
console.log(name2); // [String: 'Steve']{ age: 18 }
console.log(typeof name1); //string
console.log(typeof name2); // object
```
## 复制值
原始值，进行赋值时，原始值会赋值到新变量的位置。 因此两个变量是独立的
``` js
let num1 = 5
let num2 = num1
num1 = 10
console.log(num1, num2); // 10 5
```
引用值，进行赋值时，实际上复制的是指针，指向堆内存的对象，因此二者是同一个变量
``` js
const obj1 = {
  name: 'wuug'
}
const obj2 = obj1
obj1.name = 'steve'
console.log(obj1, obj2); // { name: 'steve' } { name: 'steve' }
```
## 函数传递参数
原始值,很好理解，直接独立的参数
``` js
function add(num) {
  return num += 10
}
let num = 10
let result = add(num)
console.log(num); //10
console.log(result); // 20
```
引用值,将指针，也就是内存地址赋值过去了，在内存地址未改变之前，指向的是同一个对象。
> 问题是引用值不是本身就是这样处理的么
``` js
// 直接修改变量，引用值发生改变
function changeName(obj) {
  obj.name = 'steve'
}
const obj = {
  name: 'Nico'
}
changeName(obj)
console.log(obj.name);  //steve
// 但这个obj仍是按值传参的
function changeObj(obj) {
  obj.name = 'Nico'
  obj = new Object()
  obj.name = "Steve"
  return obj
}
const obj = {}
const result = changeObj(obj)
console.log(obj); // {name:'Nico'}
console.log(result);// {name:'Steve}
```
## 确定类型
### typeof 
判断是都是字符串，数值，布尔值或undefined。但对null和对象作用就不是那么大了
### instanceof
可以确定具体的对象的类型，其实就是其所属的类啦，和原型链相关。
``` js
const array = [2, 2, 2, 2, 1]
console.log(typeof array); // object，是对象，但无法确定是什么对象
console.log(array instanceof Array); //true, 判断其是不是Array对象
const pattern = /ks/
console.log(typeof pattern); // object
console.log(pattern instanceof RegExp); //true
```
> 在某些浏览器中正则表达式，可能是function类型
# 执行上下文与作用域
+ 上下文决定了其能访问那些数据和它们的行为。每个上下文都有一个关联的变量对象(variable object)用来存储这个上下文定义的所有变量和函数
+ var会定义在全局变量上，而let、const的顶级声明(?)不会
+ 函数调用有着自己的上下文，这应该就是闭包了
+ 函数将活动对象(activation object)作为变量对象，通常最初只有一个定义变量：arguments
+ 作用域链(scope chain)，代码执行时，延作用域链从前往后进行标识符解析
## 作用域链增强
在以下语句时，会进行作用域增强，也就是在作用域前端临时添加一个上下文：
+ try/catch
+ with
``` js
(function buildUrl() {
  let qs = 'url='
  //with在作用域前端临时添加了一个上下文，所以外部是无法访问其内部设置的变量的。可是if也是这样啊，为什么if不算在上面的语句当中呢？
  with (location) { 
    let url = qs + href
  }
  return url  //ReferenceError: url is not defind
})()
```
## 变量声明
