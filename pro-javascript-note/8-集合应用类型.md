# Object
## 创建Object的两种方法
``` js
// 构造函数
let person = new Object()
person.name = 'Niko'
// 字面量
const person = {
  name: 'Nico',
  age: 18
}
```
> 在使用对象字面量表示法定义对象时，并不会调用Object构造函数

字面量表示法中，属性名可以是字符串或数值
``` js
let person = {
  name: 'Noki',
  5: '五'
}
console.log(person[5]); // 五
```
> 对必选参数使用命名参数，通过对象字面量来封装多个可选参数？
## 使用属性的两种方法
点语法和中括号,中括号的适用性更广一点(如空格和变量)
# Array
## 创建数组
Array构造函数
> 使用Array时可以省略new关键字
``` js
let colors = new Array() //空数组
let keys = new Array(20) //建立初始length20的空数组

let colors = new Array('green', 'blue', 'shift') // [ 'green', 'blue', 'shift' ]
```
数组字面量

> 字面量也不会调用Array构造函数
``` js
let colors = ['red','blue','green']
```
### Array.from() 将类数组结构转换为数组实例，第一个参数是一个类数组对象。
``` js
console.log(Array.from('Matt')); // [ 'M', 'a', 't', 't' ]

const m = new Map().set(1, 2).set(3, 4)
const s = new Set().add(1).add(2).add(3).add(4)
console.log(Array.from(m)); // [ [ 1, 2 ], [ 3, 4 ] 
console.log(Array.from(s)); // [ 1, 2, 3, 4 ]

// 数组浅复制
const a1 = [1, 2, 3, 4, 5]
const a2 = Array.from(a1)
console.log(a2); // [1,2,3,4,5]
console.log(a1 == a2); // false
// 迭代对象
const iter = {
  *[Symbol.iterator]() {
    for (let i = 0; i < 5; i++) {
      yield i
    }
  }
}
console.log(Array.from(iter)); // [0, 1, 2, 3, 4]

// 存在必要属性的自定义对象
const arrayLikeObj = {
  0: 1,
  1: 2,
  2: 3,
  length: 3
}
console.log(Array.from(arrayLikeObj)); // [1, 2, 3]
```
Array.from()的第二个可选的映射参数
``` js
// Array.from的第二个参数
const a1 = [1, 2, 3, 4]
const a2 = Array.from(a1, x => x ** 2) // [1, 4, 9, 16]
const a3 = Array.from(a1, function (x) {
  return x ** 2
})
console.log(a3); // [1, 4, 9, 16]
```
> Array.from还接受第三个参数，用于指定映射函数中的this值，当然箭头函数不能使用
``` js
const a1 = [1,2,3,4]
const a3 = Array.from(a1, function (x) {
  console.log(this); //[1,2,3,4]
  return x ** 2
}, a1)
```
### Arrayof()
将一组参数转换为数组，用于替代Array.prototype.slice.call(arguments)
``` js
// 不过直接使用Array()不行嘛，为什么要使用这个？
console.log(Array.of(2, 3, 4));
console.log(Array(undefined));
console.log(Array.of(undefined));
```
## 数组空位
中间创建的空位会被当作undefined，但是在不同的方法中的处理不一样，因此避免使用数组空位。若需要空位，显示的使用undefined
``` js
const options = [1, , , , 5]
console.log(options.length); //5
for (const value of options) {
  console.log(value);
}
// 1
// undefined
// undefined
// undefined
// 5

// for-in的行为就不同
for (const value in options) {
  console.log(value);
}
// 5
// 0
// 4
```
## 数组索引
``` js
let colors = ['blue', 'red', 'yellow']
// 超过最大索引，会自动扩张到该索引,中间补空
colors[5] = 'pink'
console.log(colors); //[ 'blue', 'red', 'yellow', <1 empty item>, 'pink' ]
```
> 数组最多可以包含42949967295
## 检测数组
+ instanceof() 一个全局作用域时是够用的
+ isArray()：若是网页中有多个框架，可能会有不同版本的Array构造函数，因此可能无法使用instanceof
``` js
let value = [1]
console.log(value instanceof Array); // true
console.log(Array.isArray(value)); // true
```
## 迭代器方法
keys(),values(),entries()
``` js
const a = ['foo', 'bar', 'buz', 'qux']
const aKeys = Array.from(a.keys())
const aValues = Array.from(a.values())
const aEntries = Array.from(a.entries())
console.log(aKeys); // [0, 1, 2, 3]
console.log(aValues);// ['foo', 'bar', 'buz', 'qux']
console.log(aEntries); // [[0, 'foo'], [1, 'bar'], [2, 'buz'], [3, 'qux']]
```
利用ES6解构可以很容的在循环中使用键/值,这个结构很有意思
``` js
const a = ['foo', 'bar', 'buz', 'qux']
for (const [index, value] of a.entries()) {
  console.log(index, value);
}
// 0 foo
// 1 bar
// 2 buz
// 3 qux
```
## 复制和填充方法
### fill()
可接受三个参数
``` js
const zeroes = [0, 0, 0, 0, 0]
zeroes.fill(5)
console.log(zeroes); // [ 5, 5, 5, 5, 5 ]

zeroes.fill(0)
zeroes.fill(6, 3) // >=3
console.log(zeroes); //[ 0, 0, 0, 6, 6 ]

zeroes.fill(0)
zeroes.fill(7, 1, 3) // >=1 && <3
console.log(zeroes); // [ 0, 7, 7, 0, 0 ]


zeroes.fill(0)
zeroes.fill(8, -4, -1) // --> -4+length   -1+length
console.log(zeroes); // [ 0, 8, 8, 8, 0 ] 
```
自动忽略超出数组边界、零长度及方向相反的索引范围
``` js
const zeroes = [0, 0, 0, 0, 0]
zeroes.fill(8, 3, 2) //忽略
zeroes.fill(8, 5, 10) //忽略
zeroes.fill(8, -10, -6) //忽略
``` 
### copyWithin()
在array中浅复制，并进行插入。类似fill()
``` js
let ints = [],
  reset = () => { ints = [0, 1, 2, 3, 4, 5, 6, 7, 8] }

reset()
// 复制0开始，从索引5插入
ints.copyWithin(5)
console.log(ints);// [0, 1, 2, 3, 4, 0, 1, 2, 3]

reset()
// 从5开始复制，从索引0位置插入
ints.copyWithin(0, 5)
console.log(ints);// [5, 6, 7, 8, 4, 5, 6, 7, 8]

reset()
// 从0开始复制至2(3不包括和fill一样)，在4位置插入
ints.copyWithin(4, 0, 3)
console.log(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8]

reset()
// JavaScript在查之前，会完整复制，不存在重写的问题
ints.copyWithin(2, 0, 6)
console.log(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8]

//对负索引的处理和fill是一样的
reset()
ints.copyWithin(2, -8, -3)
console.log(ints); // [0, 1, 1, 2, 3, 5, 6, 7, 8]
```
## 转换方法
``` js
let color = ['green', 'blue', 'yellow']
console.log(color.toString()); //green,blue,yellow
console.log(color.valueOf()); //[ 'green', 'blue', 'yellow' ]
```
toString()和toLocaleString()的区别
``` js
let person1 = {
  toString() {
    return 'Niko'
  },
  toLocaleString() {
    return 'NNNNNN'
  }
}
let person2 = {
  toString() {
    return 'Gero'
  },
  toLocaleString() {
    return 'GGGG'
  }
}
let persons = [person1, person2]
alert(persons) // Niko,Gero
console.log(persons.toString());
console.log(persons.toLocaleString());
```
Join(), split()的对应功能，将数组连接成字符串
``` js
let colors = ['green', 'red', undefined, 'yellow'] 
let colorsStr = colors.join('|')// 若是没参数，则默认使用','
console.log(colorsStr);// green|red||yellow  undefined被当作空字符处理了
```
## 栈方法
push(), pop()
``` js
let names = ['wu', 'nico']
console.log(names.push('gero', 'sks')); //4 返回数组长度
console.log(names.pop()); // sks
```
## 队列方法
shift() unshift()
``` js
let names = ['wu', 'nico']
console.log(names.shift()); //wu
console.log(names.unshift('gero')); //2,返回数组长度
```
## 排序方法
sort() reverse()
``` js
let values = [0, 1, 5, 10, 15]
values.reverse()
console.log(values); // [15, 10, 5, 1, 0]
values.sort()
console.log(values); // [0, 1, 10, 15, 5] 转换为string，由字符串来决定顺序
```
sort() 接受一个比较函数
``` js
// 比较函数接受两个参数,value1需要排在value2之前，就返回-1 反之返回1 .相等返回0
function compare(value1, value2) {
  if (value1 > value2) {
    return 1
  } else if (value1 < value2) {
    return -1
  } else {
    return 0
  }
}
let values = [0, 1, 5, 10, 15]
values.sort(compare)
console.log(values);
```
## 操作方法
concat(),创建新数组。
``` js
// 操作方法
let colors = ['green', 'red', 'blue']
let colors2 = colors.concat('black', colors)
console.log(colors2); // ['green', 'red', 'blue', 'black', 'green', 'red', 'blue']
```
阻止concat()打平数组的行为
``` js
// 重写concat的flat行为
let nums = [1, 2, 3, 4]
let newNums = [5, 6, 7]
newNums[Symbol.isConcatSpreadable] = false // true则打平数组，false不打平
console.log(nums.concat(newNums));  // [ 1, 2, 3, 4, [ 5, 6, 7 ] ]
```
slice()
``` js
let nums = [1, 2, 3, 4, 5, 6]
let nums2 = nums.slice(1) // [2, 3, 4, 5, 6]
let nums3 = nums.slice(1, 3) // [2, 3]
```
**splice()**删除，插入，替换。改变原数组
``` js
let nums = [0, 1, 2, 3, 4, 5]
console.log(nums.splice(0, 2)); //[0,1]  返回被删除的值组成的数组
console.log(nums); // [2,3,4,5]  

nums = [0, 1, 2, 3, 4, 5]
console.log(nums.splice(1, 0, 'fist', 'second'));  // []
console.log(nums); // // [0,'first','second',1,2,3,4,5] 在指定位置前插入

nums = [0, 1, 2, 3, 4, 5]
console.log(nums.splice(1, 1, 'first', 'second')); // [1]
console.log(nums);// [0,'first','second',2,3,4,5] // 删除同时指定位置前插入
```
## 搜索和位置方法
### 严格相等
indexOf(), lastIndexOf(),includes() 接受两个参数，要查找的元素和从一个起始位置
``` js
let nums = [1, 2, 3, 4, 5, 4, 3, 2, 1]
console.log(nums.indexOf(4)); // 3 返回4所在位置的索引
console.log(nums.lastIndexOf(4)) // 5
console.log(nums.includes(4)); // true
console.log(nums.indexOf(4, 4)); // 5
console.log(nums.lastIndexOf(4, 4)) // 3
console.log(nums.includes(4, 7)); // false
```
严格相等
``` js
let person = { name: 'Nico' }
let people = [{ name: 'Nico' }]
let people2 = [person]
console.log(people.indexOf(person));  // -1
console.log(people2.indexOf(person)); // 0
console.log(people.includes(person)); // false
console.log(people2.includes(person)); // true
```
### 断言函数
断言函数接受三个参数：元素，索引和数组本身,断言返回针织。表示是否匹配

find(),findIndex(),参数：[断言函数[指定this值]]
``` js
const people = [
  { name: 'Nico', age: 17 },
  { name: 'Gero', age: 20 }
]
const judgeAge = (element, index, array) => element.age <= 18
console.log(people.find(judgeAge)); // [{ name: 'Nico', age: '17' }]
console.log(people.findIndex(judgeAge)); // 0
```
找到匹配后，两个方法都不再继续搜索
``` js
const num = [0, 1, 2, 3, 4]
const result = num.find((element, index, array) => {
  console.log(element, index, array);
  return element === 2
})
// 0 0 [ 0, 1, 2, 3, 4 ]
// 1 1 [ 0, 1, 2, 3, 4 ]
// 2 2 [ 0, 1, 2, 3, 4 ]
console.log(result); // [2]
```
## 迭代方法
以下五个方法不改变原数组
+ every()
+ filter()
+ forEach()
+ map()
+ some()

every()都需要满足条件,some()一项满足条件
``` js
let num = [1, 2, 3, 4, 5, 4, 3, 2, 1]
let everyResult = num.every((item, index, array) => item > 2) // false
let someResult = num.some((item, index, array) => item > 2) // true
console.log(num.includes(2));// true,不能使用断言函数
```
filter()
``` js
let nums = [1, 2, 3, 4, 3, 2, 1]
let filterResult = nums.filter((item, index, array) => item < 2)
console.log(filterResult); //[1, 1]
```
map()
``` js
let nums = [1, 2, 3, 4, 5, 4, 3, 2, 1]
let mapRes = nums.map((item, index, array) => item ** 2)
console.log(mapRes);[1, 4, 9, 16] // [1, 4, 9, 16, 25, 16, 9, 4, 1]
```
forEach(),本质上相当与for循环遍历数组
``` js
let nums = [1, 2, 3, 4]
console.log(nums.forEach((item, index, array) => item > 2)); //返回undefined
```