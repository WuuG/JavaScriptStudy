# Object
## 创建Object的两种方法
``` js
// 构造函数
let person = new Object()
person.name = 'Niko'
// 字面量
const person = {
  name: 'Nico',
  age: 18
}
```
> 在使用对象字面量表示法定义对象时，并不会调用Object构造函数

字面量表示法中，属性名可以是字符串或数值
``` js
let person = {
  name: 'Noki',
  5: '五'
}
console.log(person[5]); // 五
```
> 对必选参数使用命名参数，通过对象字面量来封装多个可选参数？
## 使用属性的两种方法
点语法和中括号,中括号的适用性更广一点(如空格和变量)
# Array
## 创建数组
Array构造函数
> 使用Array时可以省略new关键字
``` js
let colors = new Array() //空数组
let keys = new Array(20) //建立初始length20的空数组

let colors = new Array('green', 'blue', 'shift') // [ 'green', 'blue', 'shift' ]
```
数组字面量

> 字面量也不会调用Array构造函数
``` js
let colors = ['red','blue','green']
```
### Array.from() 将类数组结构转换为数组实例，第一个参数是一个类数组对象。
``` js
console.log(Array.from('Matt')); // [ 'M', 'a', 't', 't' ]

const m = new Map().set(1, 2).set(3, 4)
const s = new Set().add(1).add(2).add(3).add(4)
console.log(Array.from(m)); // [ [ 1, 2 ], [ 3, 4 ] 
console.log(Array.from(s)); // [ 1, 2, 3, 4 ]

// 数组浅复制
const a1 = [1, 2, 3, 4, 5]
const a2 = Array.from(a1)
console.log(a2); // [1,2,3,4,5]
console.log(a1 == a2); // false
// 迭代对象
const iter = {
  *[Symbol.iterator]() {
    for (let i = 0; i < 5; i++) {
      yield i
    }
  }
}
console.log(Array.from(iter)); // [0, 1, 2, 3, 4]

// 存在必要属性的自定义对象
const arrayLikeObj = {
  0: 1,
  1: 2,
  2: 3,
  length: 3
}
console.log(Array.from(arrayLikeObj)); // [1, 2, 3]
```
Array.from()的第二个可选的映射参数
``` js
// Array.from的第二个参数
const a1 = [1, 2, 3, 4]
const a2 = Array.from(a1, x => x ** 2) // [1, 4, 9, 16]
const a3 = Array.from(a1, function (x) {
  return x ** 2
})
console.log(a3); // [1, 4, 9, 16]
```
> Array.from还接受第三个参数，用于指定映射函数中的this值，当然箭头函数不能使用
``` js
const a1 = [1,2,3,4]
const a3 = Array.from(a1, function (x) {
  console.log(this); //[1,2,3,4]
  return x ** 2
}, a1)
```
### Arrayof()
将一组参数转换为数组，用于替代Array.prototype.slice.call(arguments)
``` js
// 不过直接使用Array()不行嘛，为什么要使用这个？
console.log(Array.of(2, 3, 4));
console.log(Array(undefined));
console.log(Array.of(undefined));
```
## 数组空位
中间创建的空位会被当作undefined，但是在不同的方法中的处理不一样，因此避免使用数组空位。若需要空位，显示的使用undefined
``` js
const options = [1, , , , 5]
console.log(options.length); //5
for (const value of options) {
  console.log(value);
}
// 1
// undefined
// undefined
// undefined
// 5

// for-in的行为就不同
for (const value in options) {
  console.log(value);
}
// 5
// 0
// 4
```
## 数组索引
``` js
let colors = ['blue', 'red', 'yellow']
// 超过最大索引，会自动扩张到该索引,中间补空
colors[5] = 'pink'
console.log(colors); //[ 'blue', 'red', 'yellow', <1 empty item>, 'pink' ]
```
> 数组最多可以包含42949967295
## 检测数组
+ instanceof() 一个全局作用域时是够用的
+ isArray()：若是网页中有多个框架，可能会有不同版本的Array构造函数，因此可能无法使用instanceof
``` js
let value = [1]
console.log(value instanceof Array); // true
console.log(Array.isArray(value)); // true
```
## 迭代器方法
keys(),values(),entries()
``` js
const a = ['foo', 'bar', 'buz', 'qux']
const aKeys = Array.from(a.keys())
const aValues = Array.from(a.values())
const aEntries = Array.from(a.entries())
console.log(aKeys); // [0, 1, 2, 3]
console.log(aValues);// ['foo', 'bar', 'buz', 'qux']
console.log(aEntries); // [[0, 'foo'], [1, 'bar'], [2, 'buz'], [3, 'qux']]
```
利用ES6解构可以很容的在循环中使用键/值,这个结构很有意思
``` js
const a = ['foo', 'bar', 'buz', 'qux']
for (const [index, value] of a.entries()) {
  console.log(index, value);
}
// 0 foo
// 1 bar
// 2 buz
// 3 qux
```
## 复制和填充方法
### fill()
可接受三个参数
``` js
const zeroes = [0, 0, 0, 0, 0]
zeroes.fill(5)
console.log(zeroes); // [ 5, 5, 5, 5, 5 ]

zeroes.fill(0)
zeroes.fill(6, 3) // >=3
console.log(zeroes); //[ 0, 0, 0, 6, 6 ]

zeroes.fill(0)
zeroes.fill(7, 1, 3) // >=1 && <3
console.log(zeroes); // [ 0, 7, 7, 0, 0 ]


zeroes.fill(0)
zeroes.fill(8, -4, -1) // --> -4+length   -1+length
console.log(zeroes); // [ 0, 8, 8, 8, 0 ] 
```
自动忽略超出数组边界、零长度及方向相反的索引范围
``` js
const zeroes = [0, 0, 0, 0, 0]
zeroes.fill(8, 3, 2) //忽略
zeroes.fill(8, 5, 10) //忽略
zeroes.fill(8, -10, -6) //忽略
``` 
### copyWithin()
在array中浅复制，并进行插入。类似fill()
``` js
let ints = [],
  reset = () => { ints = [0, 1, 2, 3, 4, 5, 6, 7, 8] }

reset()
// 复制0开始，从索引5插入
ints.copyWithin(5)
console.log(ints);// [0, 1, 2, 3, 4, 0, 1, 2, 3]

reset()
// 从5开始复制，从索引0位置插入
ints.copyWithin(0, 5)
console.log(ints);// [5, 6, 7, 8, 4, 5, 6, 7, 8]

reset()
// 从0开始复制至2(3不包括和fill一样)，在4位置插入
ints.copyWithin(4, 0, 3)
console.log(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8]

reset()
// JavaScript在查之前，会完整复制，不存在重写的问题
ints.copyWithin(2, 0, 6)
console.log(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8]

//对负索引的处理和fill是一样的
reset()
ints.copyWithin(2, -8, -3)
console.log(ints); // [0, 1, 1, 2, 3, 5, 6, 7, 8]
```
## 转换方法
``` js
let color = ['green', 'blue', 'yellow']
console.log(color.toString()); //green,blue,yellow
console.log(color.valueOf()); //[ 'green', 'blue', 'yellow' ]
```
toString()和toLocaleString()的区别
``` js
let person1 = {
  toString() {
    return 'Niko'
  },
  toLocaleString() {
    return 'NNNNNN'
  }
}
let person2 = {
  toString() {
    return 'Gero'
  },
  toLocaleString() {
    return 'GGGG'
  }
}
let persons = [person1, person2]
alert(persons) // Niko,Gero
console.log(persons.toString());
console.log(persons.toLocaleString());
```
Join(), split()的对应功能，将数组连接成字符串
``` js
let colors = ['green', 'red', undefined, 'yellow'] 
let colorsStr = colors.join('|')// 若是没参数，则默认使用','
console.log(colorsStr);// green|red||yellow  undefined被当作空字符处理了
```
## 栈方法
push(), pop()
``` js
let names = ['wu', 'nico']
console.log(names.push('gero', 'sks')); //4 返回数组长度
console.log(names.pop()); // sks
```
## 队列方法
shift() unshift()
``` js
let names = ['wu', 'nico']
console.log(names.shift()); //wu
console.log(names.unshift('gero')); //2,返回数组长度
```
## 排序方法
sort() reverse()
``` js
let values = [0, 1, 5, 10, 15]
values.reverse()
console.log(values); // [15, 10, 5, 1, 0]
values.sort()
console.log(values); // [0, 1, 10, 15, 5] 转换为string，由字符串来决定顺序
```
sort() 接受一个比较函数
``` js
// 比较函数接受两个参数,value1需要排在value2之前，就返回-1 反之返回1 .相等返回0
function compare(value1, value2) {
  if (value1 > value2) {
    return 1
  } else if (value1 < value2) {
    return -1
  } else {
    return 0
  }
}
let values = [0, 1, 5, 10, 15]
values.sort(compare)
console.log(values);
```