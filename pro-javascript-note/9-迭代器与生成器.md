# 迭代器
## 迭代器模式
将有些结构称为“可迭代对象”，这些结构有着正式的iterator接口，并通过迭代器iterator消费。

iterator无需了解iterable对象的内部结构。
## 可迭代协议
实现可迭代接口(可迭代协议)必须具备两种能力:
1. 支持迭代的自我识别能力
2. 创建实现iterator接口的对象的能力

Symbol.iterator作为键，引用一个迭代器工厂函数，调用工厂函数必须返回一个新迭代值。

实现的iterator接口的内置类型:
+ 字符串
+ 数组
+ 映射
+ 集合
+ arguments对象
+ NodeList等DOM集合类型
``` js
let num = 1
let obj = {}
console.log(num[Symbol.iterator]); // undefined
console.log(obj[Symbol.iterator]); // undefined
let str = 'abc'
let arr = ['a', 'b', 'c']
let map = new Map().set('a', 1).set('b', 2).set('c', 3)
let set = new Set([...arr])
// let els = document.querySelectorAll('div')
// 以下类型都是先了迭代器工厂函数
console.log(str[Symbol.iterator]);
console.log(arr[Symbol.iterator]);
console.log(map[Symbol.iterator]);
console.log(set[Symbol.iterator]);
console.log(str[Symbol.iterator]);
// console.log(els[Symbol.iterator]);
// 调用工厂函数会生产一个迭代器
console.log(str[Symbol.iterator]());
console.log(arr[Symbol.iterator]());
console.log(map[Symbol.iterator]());
console.log(set[Symbol.iterator]());
console.log(str[Symbol.iterator]());
// Object [String Iterator] {}
// Object [Array Iterator] {}
// [Map Entries] { [ 'a', 1 ], [ 'b', 2 ], [ 'c', 3 ] }
// [Set Iterator] { 'a', 'b', 'c' }
// Object [String Iterator] {}
```
实际使用时，不需要显示调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型会自动兼容接受可迭代对象的任何语言特性。接受可迭代对象的原生语言特性包括：
+ for-of循环
+ 数组解构
+ 扩展操作符
+ Array.from()
+ 创建集合
+ 创建映射
+ promise.all()接受由期约组成的可迭代对象
+ promise.race()接受由期约组成的可迭代对象
+ yield*操作符，在生成器中使用

即以上原生语言解构会在后台调用可迭代对象的工厂函数，从而创建迭代器。
``` js
let arr = ['foo', 'bar', 'baz']
for (let el of arr) {
	console.log(el);
}
// foo
// bar
// baz
let [a, b, c] = arr;
console.log(a, b, c); // foo bar baz
let arr2 = [...arr]
console.log(arr2); // [ 'foo', 'bar', 'baz' ]
let arr3 = Array.from(arr)
console.log(arr3); // [ 'foo', 'bar', 'baz' ]
let set = new Set(arr)
console.log(set); // Set(3) { 'foo', 'bar', 'baz' }
let pairs = new Map(arr.map(x => [x, `val${x}`]))
console.log(pairs); // Map(3) { 'foo' => 'valfoo', 'bar' => 'valbar', 'baz' => 'valbaz' }
```
父类实现iterator接口，这个对象也实现了这个接口
``` js
class FooArray extends Array { }
let fooArr = new FooArray('foo', 'bar', 'buz')
for (let el of fooArr) {
	console.log(el);
}
// foo
// bar
// buz
```
## 迭代器协议
迭代器是一种一次性使用的对象，用于迭代于其关联的可迭代对象。next()方法在可迭代对象中遍历数据。每次调用next()都会返回一个IteratorResult对象，其中包含迭代器返回的下一个值。

next()方法返回的IteratorResult包含两个属性：done和value。done表示是否还可以调用next(),value包含可迭代对象的下一个值(done为false),或者undefined(done为true)。
``` js
let arr = ['foo', 'bar']
console.log(arr[Symbol.iterator]); // [Function: values]
let iter = arr[Symbol.iterator]()
console.log(iter); // Object [Array Iterator] {}
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
// { value: 'foo', done: false }
// { value: 'bar', done: false }
// { value: undefined, done: true } 
// 到达done后就调用就返回同样的值了
// { value: undefined, done: true }
```
不同的迭代器实例相互之间没有联系，独立的遍历可迭代对象,可以嵌套使用啦，看来
``` js
let arr = ['foo']
let iter1 = arr[Symbol.iterator]()
let iter2 = arr[Symbol.iterator]()
console.log(iter1.next());
console.log(iter2.next());
console.log(iter1.next());
console.log(iter2.next());
// { value: 'foo', done: false }
// { value: 'foo', done: false }
// { value: undefined, done: true }
// { value: undefined, done: true }
```
迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程(指针？)。换句话说，如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化：
``` js
let arr = ['foo', 'baz']
let iter = arr[Symbol.iterator]()
console.log(iter.next()); // {value:'foo',done:false}
arr.splice(1, 0, 'buz')
console.log(iter.next()); // {value:'buz',done:false}
console.log(iter.next()); // {value:'baz',done:false}
```
> 迭代器维护者一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象，游标引用吗？

迭代器可以指通用的迭代（内部实现的）,也可以指接口,还可以指正式的迭代器类型。下面是显示迭代器和原生迭代器的实现。
``` js
class Foo {
	[Symbol.iterator]() {
		return {
			next() {
				return { done: false, value: 'foo' }
			}
		}
	}
}
let f = new Foo()
console.log(f[Symbol.iterator]());// { next: [Function: next] }
let a = new Array()
console.log(a[Symbol.iterator]());// Object [Array Iterator] {}
```
## 自定义迭代器
``` js
class Count {
	constructor(limit) {
		this.count = 1;
		this.limit = limit
	}
	next() {
		if (this.count <= this.limit) {
			return { done: false, value: this.count++ }
		} else {
			return { done: true, value: undefined }
		}
	}
	[Symbol.iterator]() {
		return this
	}
}
let counter = new Count(3)
for (let i of counter) {
	console.log(i);
}
// 1
// 2
// 3
```
上例实现了iterator接口，但其每个实例只能被迭代一次。


为了让可迭代对象创建多个对象，因此每创建一个迭代器就对应一个新技术器。为此，可以把计数器变量放到闭包里，再通过闭包返回迭代器 ??? 这...
``` js
class Counter {
	constructor(limit) {
		this.limit = limit
	}
	[Symbol.iterator]() {
		let count = 1,
			limit = this.limit
		return {
			next() {
				if (count <= limit) {
					return { done: false, value: count++ }
				} else {
					return { done: true, value: undefined }
				}
			}
		}
	}
}
let count = new Counter(3)
for (const i of count) { console.log(i); } // 1 2 3
for (const i of count) { console.log(i); } // 1 2 3
```
iterator也有Symbol.iterator属性,其Symbol.iterator属性引用的工厂函数会返回相同的迭代器。
``` js
let arr = ['foo', 'bar', 'baz']
let iter1 = arr[Symbol.iterator]()
console.log(iter1); // Object [Array Iterator] {}
console.log(iter1[Symbol.iterator]()); // Object [Array Iterator] {}
let iter2 = iter1[Symbol.iterator]()
console.log(iter1 === iter2); //true
```
## 提前终止迭代器
return()方法，用于指定迭代器提前关闭时执行的逻辑。执行迭代的结构，若不要遍历到可迭代对象耗尽时，可以通过以下方法“关闭迭代器”:
+ for-of循环通过break，continue，return或throw提前提出
+ 解构操作并未消费所有值

return()方法必须返回一个有效的iteratorResult对象。简单情况下，可以只返回{done:true}
``` js
class Counter {
	constructor(limit) {
		this.limit = limit
	}
	[Symbol.iterator]() {
		let count = 1,
			limit = this.limit
		return {
			next() {
				if (count <= limit) {
					return { value: count++, done: false }
				} else {
					return { value: undefined, done: true }
				}
			},
			return() {
				console.log('Early Exit');
				return { done: true }
			}
		}
	}
}
let counter1 = new Counter(3)
for (let i of counter1) {
	if (i > 2) {
		break
	}
	console.log(i);
}
// 1
// 2
// Early Exit
for (let i of counter1) {
	try {
		if (i > 2) {
			throw 'err'
		}
		console.log(i);
	} catch (error) { }
}
// 1
// 2
// 为什么没有Early Exit呢？
let counter2 = new Counter(3)
let [a, b] = counter2
// Early Exit
```
若迭代器没有关闭(就是没有return方法)，则会从上次离开的地方继续迭代。比如数组的迭代器就是不能关闭的。
``` js
let a = [1, 2, 3, 4, 5]
let iter = a[Symbol.iterator]()
for (const i of iter) {
	console.log(i);
	if (i > 2) {
		break
	}
}
// 1
// 2
// 3
for (const i of iter) {
	console.log(i);
}
// 4
// 5
```
因为return()方法可选，所以不是所有迭代器都是可关闭的。可以通过迭代器的return属性是不是函数对象来判断是否可关闭。不过仅仅给一个不可关闭的迭代器添加这个属性，并不会使其变成可关闭的迭代器。因为调用return()不会强制迭代器进入关闭状态。但return()方法会被调用
``` js
let a = [1, 2, 3, 4, 5]
let iter = a[Symbol.iterator]()
iter.return = function () {
	console.log('Early Exit');
	return { done: true }
}
for (const i of iter) {
	console.log(i);
	if (i > 2) {
		break
	}
}
// 1
// 2
// 3
// Early Exit
for (const i of iter) {
	console.log(i);
}
// 4
// 5
```
# 生成器
生成器的形式是一个函数，函数名称前面加星号(*)表示其是一个生成器。只要可以定义函数的地方，就可以定义生成器
> 箭头函数不能用来定义生成器函数
``` js
function* generatorFn() {}
let generatorFn = function *() {}
let foo = {
	*generatorFn(){}
}
class Foo {
	* generatorFn() {}
}
class Bar {
	static *generatorFn() {}
}
```
> 生成器的星号不受两侧空格的影响

调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行(suspended)的状态。与迭代器相似，生成器对象也实现了Iterator接口，因此具有next()方法。调用这个方法会让生成器开始或恢复执行。
