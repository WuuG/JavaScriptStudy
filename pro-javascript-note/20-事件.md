- [事件流](#事件流)
	- [事件冒泡](#事件冒泡)
	- [事件捕获](#事件捕获)
	- [DOM事件流](#dom事件流)
- [事件处理程序](#事件处理程序)
	- [HTML事件处理程序](#html事件处理程序)
	- [DOM0事件处理程序](#dom0事件处理程序)
	- [DOM2事件处理程序](#dom2事件处理程序)
	- [IE事件处理程序](#ie事件处理程序)
	- [跨浏览器事件处理程序](#跨浏览器事件处理程序)
- [事件对象](#事件对象)
	- [DOM事件对象](#dom事件对象)
	- [IE事件对象](#ie事件对象)
	- [跨浏览器事件对象](#跨浏览器事件对象)
# 事件流
事件冒泡和事件捕获流。 完全相反的两种事件接受的方法
## 事件冒泡
事件从最具体的元素(文档中最深的节点)开始触发，初步向上传播.如下代码，在点击div后会逐步向上传播div->body->html->document
``` html
<html lang="en">
<body>
	<div></div>
</body>
</html>
```
所有现代浏览器都支持事件冒泡，只是在实现方式上会有一些变化。早期IE会跳过html。而现代浏览器中的事件会一直冒泡到window对象
## 事件捕获
事件捕获恰好与事件冒泡相反，最不具体的元素先收到事件，最具体的元素后收到事件。如上代码则会从document->html->body->div的顺序传播。

现代浏览器均支持事件捕获。实际上所有的浏览器都是从window对象开始捕获事件的，而DOM2 Events规范规定从document开始。

> 由于旧版本浏览器不支持，因此实际中几乎不会使用事件捕获。通常建议使用事件冒泡，特殊情况下使用事件捕获。
## DOM事件流
DOM2 Events规范规定事件流分为3个阶段：事件捕获、到达目标和事件冒泡。事件捕获最先发生，未提前拦截事件提供可能。 然后实际的目标元素接受到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。

如前文例子，在事件捕获阶段document-> html -> body 传播，注意在该阶段实际的目标元素(本例中是div)不会接受到事件。下一阶段，也就是div触发事件时，通常会被认为是冒泡阶段的一部分。

大多数支持DOM事件流的浏览器实现了一个小小的拓展。虽然DOM2 Events规范明确捕获阶段不命中事件目标。但现在浏览器都会在捕获阶段在事件目标上触发事件。最终结果是在事件目标上有两个机会来处理事件。
# 事件处理程序
## HTML事件处理程序
特定元素支持的每个事件都可以使用事件处理程序的名字以HTML属性的形式来指定。 此时的属性值必须是能够执行的Javascript代码。如下
``` html
<input type="text" value="click me" onclick="console.log('clicked')">
```
因为属性的值是Javascript代码，所以不能在未经转义的情况下使用HTML语法字符，如&,",<,>等(其实是可以使用的，只是引号存在问题而已)。如果确实要使用这些字符，则需要改动代码为下例子
``` html
<input type="text" value="click me" onclick="console.log('&quot;clicked&quot')">
```
在HTML中定义的事件处理程序可以包含精确的动作指令，也可以调用在页面其他地方定义的脚本，比如：
``` js
<input type="text" onclick="showMessage()">
<script>
	function showMessage() {
		console.log('hello world');
	}
</script>
```
以这种方式指定的事件处理程序有一些特殊的地方。首先，会创建一个函数来封装属性的值。这个函数有一个特殊的局部变量event，其实保存的就是event对象
``` html
<!-- 输出click -->
<input type="text" onclick="console.log(event.type)"> 
```
有了这个对象，就不用开发者另外定义其他变量，也不用从包装函数的参数列表中去取了。

在这个函数中，this相当于事件的目标元素，如下所示：
``` html
<!-- 输出"Click Me" -->
<input type="button" value="Click Me" onclick="console.log(this.value)">
```
这个动态创建的包装函数还有一个特别有意思的地方，就是其作用域链被扩展了。在这个函数中，document和元素自身的成员都可以被当成局部变量来访问。这是通过使用with实现的：
``` js
function() {
	with(document){
		with(this){
			// 属性值 <- 事件对应的属性值
		}
	}
}
```
这意味着事件处理程序可以更方便地访问自己的属性。下面的代码于前面的示例功能一样：
``` html
<!-- 输出"Click Me" -->
<input type="button" value="Click Me " onclick="console.log(value)">
```
如果这个元素是一个表单输入框，则作用域中还会表单元素，事件处理程序对应的函数等价于如下：
``` js
function() {
	with(docuemnt){
		with(this.form) {
			with(this){
				// 属性值
			}
		}
	}
}
```
本质上，经过这样的扩展，事件处理程序的代码就不必应用表单元素，而直接访问同一表单中的其他成员了。如下
``` html
<form method="post">
	<!-- 打印button的value -->
	<input type="text" name="username" value="" onclick="console.log(button.value)">
	<!-- 打印上面的value -->
	<input type="button" value="Echo Username" onclick="console.log(username.value)" name="button">
</form>
```
在HTML中指定事件处理程序还有一些问题。第一个问题是时机问题。如HTML元素已经显示在页面上，且用户都交互了，但是事件处理程序还无法执行，此时就会发生错误。为此，大多数HTML事件处理程序会封装在try/catch块中，以便在这种情况下静默失败，如下例所示：
``` js
<script>
	function showMessage() {
		console.log('hello world');
	}
</script>
<input type="button" value="Click Me" onclick="try {showMessage()} catch(ex){}">
```
另一个问题对事件处理程序作用域链的扩展在不同浏览器中可能导致不同的结果。不同Javascript引擎中标识符解析的规则存在差异，因此访问无限定的对象成员可能导致错误。

使用HTML指定事件处理程序的最后一个问题是HTML与Javascript强耦合。使得修改事件处理程序，则必须修改两个地方。<-- 获取DOM，再添加事件，并没有方便太多吧。
## DOM0事件处理程序
在Javascript中指定处理程序的传统方式是把一个函数赋给DOM元素的一个事件处理程序属性。也就是通过获取操作对象后添加事件处理程序。如下
``` html
	<input type="button" id='myBtn' value="Click myBtn">
	<script>
		const btn = document.querySelector('#myBtn')
		btn.onclick = function () {
			console.log('click me');
		}
	</script>
```
需要注意的是，通过上诉的方法添加事件处理程序，需要在JavaScript代码运行后才会有效果。也就是说在用户点击按钮可能会出现没反应的情款，因为js代码还未运行。

像这样使用DOM0方式为事件处理程序赋值时，所附函数是为元素的方法。因此，事件处理程序会在元素的作用域中运行，即this等于元素。 以这种方式添加事件处理程序是注册在事件流的冒泡阶段。
``` html
	<form method="POST">
		<input type="text" value="value" name="input">
		<input type="button" id="myBtn2" value="click" name="button">
	</form>
	<script>
		const myBtn2 = document.querySelector('#myBtn2')
		myBtn2.onclick = function (event) {
			console.log(event);
			console.log(this); // input#myBtn2 element
			console.log(input.value); // 报错，这样就无法获取同一个form的其他元素了
		}
	</script>
```
通过将事件处理程序属性的值设置为null，可以移除通过DOM0方式添加的事件处理程序，如下
``` js
btn.onclick = null // 移除事件处理程序
```
> 如果事件处理程序实在HTML中指定的，则onclcick属性的值是一个包装相应HTML事件处理程序属性值的函数。这些事件处理程序也可以通过在JavaScript中将相应属性设置为null来移除。
## DOM2事件处理程序
DOM2 Events为事件处理程序的赋值和移除定义了两个方法：addEventLisener()remove-EventListener()。这两个方法暴露在所有DOM节点上，它们接受三个参数:事件名、事件处理程序、事件处理程序和一个布尔值，true表示在捕获阶段调用事件处理程序，false(默认值)表示在冒泡阶段调用事件处理程序。如下例：
``` html
	<input type="button" value="click me" id="btn3">
	<script>
		const btn3 = document.querySelector('#btn3')
		btn3.addEventListener('click', () => {
			console.log(this); // window
		})
		btn3.addEventListener('click', function () {
			console.log(this.id); // btn3
		})
	</script>
```
添加了两个事件处理程序，前面的会先触发，然后再打印"btn3"

通过addEventListener()添加的事件处理程序只能使用removeEventlistener()并传入与添加时相同的参数来移除。这意味着使用addEventListener()添加的匿名函数无法移除。如下
``` html
	<input type="button" value="removeEventListener" id="btn4">
	<script>
		const btn4 = document.querySelector('#btn4')
		btn4.addEventListener('click', function () {
			console.log(this.id);
		}, 'false')
		btn4.removeEventListener('click', function () { // 没有效果
			console.log(this.id);
		}, 'false')
	</script>
```
二者代码是相同的，当其实并不是同一个Function实例。若是要使用removeEventListener()，可以像如下代码：
``` html
<input type="button" value="removeEventListener correct" id="btn5">
<script>
	const btn5 = document.querySelector('#btn5')
	const hander = function () {
		console.log(this.id);
	}
	btn4.addEventListener('click', hander, 'false')
	btn4.removeEventListener('click', hander, 'false')
</script>
```
大多数情况下，事件处理程序会被添加至事件流的冒泡阶段，主要原因是跨跨浏览器兼容性好。把事件处理程序注册到捕获阶段通常用于在事件到达其指定目标之前拦截事件。如果不需要拦截，则不要使用事件捕获。
## IE事件处理程序
IE事件了与DOM类似的方法，即attachEvent()和detachEvent().这两个方法接受两个同样的参数：事件处理程序的名字和事件处理函数。因为IE8以及更早版本只支持事件冒泡，所以使用attachEvent()添加的事件处理程序会添加到冒泡阶段。
> 好像现代浏览器并不支持attachEvent方法,估计IE8以下才能使用此方法
``` html
	<input type="button" value="IE attachEvent" id='btn6'>
	<script>
		var btn6 = document.querySelector("#btn6")
		btn6.attachEvent('onclick', function () {
			console.log('click');
		})
	</script>
```
在IE中使用attachEvent()与使用DOM0方式的主要区别是事件处理程序的作用。使用DOM0方式时，事件处理程序中的this值等于目标元素。而使用attachEvent()，事件处理程序是在全局作用域中运行的，因此this等于window.
``` html
	<input type="button" value="this" id="btn">
	<script>
		var btn = document.getElementById('btn')
		btn.attachEvent('onclick', function () {
			console.log(this === window); // true
		})
	</script>
```
与addEventListener()一样，使用attachEvent()方法也可以给一个元素添加多个事件处理程序。有趣的是，与DOM方法不同，这里的事件处理程序会以添加它们的顺序方向触发。
``` html
	<input type="button" value="this" id="btn">
	<script>
		var btn = document.getElementById('btn')
		btn.attachEvent('onclick', function () {
			console.log(this === window); // true
		})
		btn.attachEvent('onclick', function () {
			console.log('define after');
		})
		// define after
		// click
	</script>
```
通过给detachEvent()提供相同参数，可以移除事件。
## 跨浏览器事件处理程序
为了以跨浏览器兼容的方式处理事件，可以通过能力检测，来进行处理。如下EventUtil对象，添加了跨浏览器的addHandler()和removeHandler()方法,同时为了使得事件处理的代码具有最大的兼容性，只需要让代码运行在冒泡阶段运行即可。
``` js
var EventUtil = {
	addHander:function(element,type,handler) {
		if(element.addEventListner) {
			element.addEventListner(type,handler,false)
		}else if(element.attachEvent) {
			element.attachEvent("on"+type,handler)
		}else {
			element["on"+type] = handler
		}
	},
	removeHandler:function(element,type,handler) {
		if(element.removeEventListenerl) {
			element.removeEventListenerl(type,handler,false)
		}else if(element.detachEvent) {
			element.detachEvent("on" + type,handler)
		}else {
			element["on"+type] = null
		}
	}
}
```
# 事件对象
DOM发生事件时，所有相关信息都会收集并存储在一个名为event的对象中。这个对象包含了一些基本信息。
## DOM事件对象
在DOM合规的浏览器中，event对象时传给事件处理程序的唯一参数。不管以哪种方式(DOM0或DOM2)指定事件处理程序，都会传入event对象。如下展示了两种方式下使用事件对象：
``` html
	<input type="button" id="btn" value="event object">
	<script>
		const btn = document.querySelector('#btn')
		btn.onclick = function (event) {
			console.log(event.type); // click
		}
		btn.addEventListener('click', (event) => {
			console.log(event.type); // click
		})
	</script>
```
当然在通过HTML属性指定的事件处理程序中，同样可以使用变量event应用事件对象
``` html
	<!-- 打印click -->
	<input type="button" value="event object html" onclick="console.log(event.type)"> 
```
如前所述，事件对象包含与特定事件相关的属性和方法。不同事件生成的事件对象也会包含不同的属性和方法。不过，所有事件对象都会包含下表列出的这些公共属性和方法。
![](index_files/20-1.png)

在事件处理程序内部，this对象始终等于currentTarget的值，而target只包含事件的实际目标。如果事件处理程序直接添加在了意图的目标。则this，currentTarget和target的值是一样的。如下例，三者就相等：
``` html
	<input type="button" value="this target currentTarget" id="btn2">
	<script>
		const btn2 = document.querySelector('#btn2')
		btn2.onclick = function (event) {
			console.log(event.target === this); // true
			console.log(event.currentTarget === this); // true
		}
	</script>
```
上面的代码检测了currentTarget和target的值是否等于this。因为click事件的目标是按钮，所以3个相等。如果这个事件处理程序是添加到按钮的父节点上，那么它们的值就不一样了。比如下面的例子在body上添加了单击处理程序
``` html
	<input type="button" value="this target currentTarget body" id="btn3">
	<script>
		const body = document.body
		body.onclick = function (event) {
			console.log(event.currentTarget === document.body);
			console.log(this === document.body);
			console.log(event.target === document.getElementById('btn3'));
		}
		// 在点击 btn3 后三个均打印 true
	</script>
```
在点击按钮后，this，currentTarget都等于document.body，这是因为他是注册事件处理程序的元素。而target属性等于按钮本身，这是因为那才是click事件真正的目标。由于按钮本身并没有注册事件处理程序，因此click事件冒泡到document.body,从而触发了在它上面注册的处理程序。

type属性在一个处理程序处理多个事件时很有用。比如下面的处理程序中就使用event.type:
``` html
	<input type="button" value="event.type" id="btn4">
	<script>
		const btn4 = document.getElementById("btn4")
		const handler = function (event) {
			switch (event.type) {
				case "click":
					console.log('Clicked');
					break
				case "mouseover":
					event.target.style.backgroundColor = "red"
					break
				case "mouseout":
					event.target.style.backgroundColor = ''
					break
			}
		}
		btn4.onclick = handler
		btn4.onmouseover = handler
		btn4.onmouseout = handler
	</script>
```
preventDefault()方法阻止特定事件的默认动作。比如，链接的默认行为就是在单击时被导航到href属性指定的URL。如果想阻止这个导航行为，可以在onclick事件处理程序中取消
``` js
	<a href="www.baidu.com" id="link">百度</a>
	<script>
		const link = document.getElementById('link')
		link.onclick = function (event) {
			event.preventDefault();
		}
	</script>
```
stopPropagation()方法用于立即阻止事件流在DOM结构中传播，取消后续事件捕获或冒泡。例如在前文body添加的事件的代码后，添加以下代码：
``` html
<!-- ...body的代码 --> 
	<input type="button" value="stop propagation" id="btn5">
	<script>
		const btn5 = document.getElementById('btn5')
		btn5.onclick = function (evnet) {
			console.log("clicked");
			evnet.stopPropagation(); //阻止了事件传播，body的click事件不会触发。
		}
	</script>
```
eventPhase属性可用于确定事件流当前所处的节点。如果事件处理程序在冒泡阶段被调用则，eventPhase等于1，如果事件处理程序在目标上被调用，则eventPhase等于2；如果事件处理程序在冒泡阶段被调用，则eventPhase等于3.不过要注意，虽然"到达目标"实在冒泡阶段发生的，但其eventPhase仍等于2. 如下：
> event对象旨在事件处理程序执行期间存在，一旦执行完毕，就会被销毁。
## IE事件对象
与DOM事件对象不同，IE事件对象可以基于事件处理程序被指定的方式以不同的方式来访问。如果事件处理程序是使用DOM0方式指定的，则event对象只是window对象的一个属性(看样子其他浏览器中也会在window中存event)，如下所示：
``` html
	<input type="button" value="click" id="btn">
	<script>
		var btn = document.getElementById('btn')
		btn.onclick = function () {
			const event = window.event
			console.log(event.type); // click
		}
	</script>
```
若是事件处理程序是使用attachEvent()指定的，则event对象会作为唯一的参数传给处理函数，如下所示：
``` html
	<input type="button" value="click attach" id="btn2">
	<script>
		var btn2 = document.getElementById('btn2')
		btn2.attachEvent('onclick', function (event) {
			console.log(event.type);
		})
	</script>
```
使用attachEvent()，event对象仍然是window对象的属性，只是出于方便也将其作为参数传入。

如果使用HTML属性方式指定事件的事件处理程序，则event对象同样可以通过变量event访问。
``` html
<input type="button" value="HTML" onclick="console.log(event.type)">
```
IE事件对象也包含导致其创建特定事件相关的属性和方法，其中很多与相关的DOM属性和方法对应。与DOM事件对象一样，基于触发的事件类型不同，event对象中包含的属性和方法也不一样。 不过所有IE事件对象都会包含下列公共属性和方法
![](index_files/20-2.png)

由于事件处理程序的作用域取决于指定它的方式，因此this值并不总是等于事件目标。为此更好的方式是使用事件对象的srcElement属性代替this。下面的例子表明，不同事件对象上的srcElement属性中保存的都是事件目标：
``` html
	<input type="button" value="srcElement" id="btn3">
	<script>
		var btn3 = document.getElementById('btn3')
		btn3.onclick = function () {
			console.log(window.event.srcElement === this); // true
		}
		btn3.attachEvent("onclick", function (event) {
			console.log(window.event.srcElement === this); // false
		})
	</script>
```
returnValue属性等价于DOM preveDefault()方法，都是用于取消给定事件默认的行为。只不过这里是设置returnValue的值为false。
``` js
	<a href="https://www.baidu.com" id="link">百度</a>
	<script>
		var link = document.querySelector('#link')
		link.onclick = function () {
			window.event.returnValue = false
		}
	</script>
```
cancelBubble属性与DOMstopPropagation()方法的用途相同，都可以阻止事件冒泡。因为IE8之前不支持捕获阶段，因此只会前者只会取消冒泡。而后者机会取消捕获也会取消冒泡
``` html
	<input type="button" value="cancelBubbte" id="btn4">
	<script>
		var btn4 = document.querySelector('#btn4')
		btn4.onclick = function () {
			console.log("clicked");
			window.event.cancelBubble = true
		}
		document.body.onclick = function () {
			console.log('body clicked');
		}
	</script>
```
## 跨浏览器事件对象
虽然DOM与IE的事件对象并不相同，但它们有足够的相似性来实现跨浏览器方案。DOM事件对象中包含IE事件对象的所有信息和能力。本章之前的EventUtil对象可以像下面一样再添加一些方法
``` js
var EventUtil = {
	//... 之前的代码
	getEvent: function (event) {
		return event ? event : window.event
	},
	getTarget:function(event) {
		return event.target || event.srcElement
	},
	preventDefault: function(event) {
		if(event.preventDefault) {
			event.preventDefault
		}else {
			event.returnValue = false
		}
	},
	stopPropagation:function(event) {
		if(event.stopPropagation){
			event.stopPropagation()
		}else {
			event.cancelBubble = true
		}
	}
}
```
