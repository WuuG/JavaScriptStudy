- [事件流](#事件流)
	- [事件冒泡](#事件冒泡)
	- [事件捕获](#事件捕获)
	- [DOM事件流](#dom事件流)
- [事件处理程序](#事件处理程序)
	- [HTML事件处理程序](#html事件处理程序)
	- [DOM0事件处理程序](#dom0事件处理程序)
	- [DOM2事件处理程序](#dom2事件处理程序)
	- [IE事件处理程序](#ie事件处理程序)
	- [跨浏览器事件处理程序](#跨浏览器事件处理程序)
- [事件对象](#事件对象)
	- [DOM事件对象](#dom事件对象)
	- [IE事件对象](#ie事件对象)
	- [跨浏览器事件对象](#跨浏览器事件对象)
- [事件类型](#事件类型)
	- [用户界面事件](#用户界面事件)
		- [load事件](#load事件)
		- [unload事件](#unload事件)
		- [resize事件](#resize事件)
		- [scroll事件](#scroll事件)
	- [焦点事件](#焦点事件)
# 事件流
事件冒泡和事件捕获流。 完全相反的两种事件接受的方法
## 事件冒泡
事件从最具体的元素(文档中最深的节点)开始触发，初步向上传播.如下代码，在点击div后会逐步向上传播div->body->html->document
``` html
<html lang="en">
<body>
	<div></div>
</body>
</html>
```
所有现代浏览器都支持事件冒泡，只是在实现方式上会有一些变化。早期IE会跳过html。而现代浏览器中的事件会一直冒泡到window对象
## 事件捕获
事件捕获恰好与事件冒泡相反，最不具体的元素先收到事件，最具体的元素后收到事件。如上代码则会从document->html->body->div的顺序传播。

现代浏览器均支持事件捕获。实际上所有的浏览器都是从window对象开始捕获事件的，而DOM2 Events规范规定从document开始。

> 由于旧版本浏览器不支持，因此实际中几乎不会使用事件捕获。通常建议使用事件冒泡，特殊情况下使用事件捕获。
## DOM事件流
DOM2 Events规范规定事件流分为3个阶段：事件捕获、到达目标和事件冒泡。事件捕获最先发生，未提前拦截事件提供可能。 然后实际的目标元素接受到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。

如前文例子，在事件捕获阶段document-> html -> body 传播，注意在该阶段实际的目标元素(本例中是div)不会接受到事件。下一阶段，也就是div触发事件时，通常会被认为是冒泡阶段的一部分。

大多数支持DOM事件流的浏览器实现了一个小小的拓展。虽然DOM2 Events规范明确捕获阶段不命中事件目标。但现在浏览器都会在捕获阶段在事件目标上触发事件。最终结果是在事件目标上有两个机会来处理事件。
# 事件处理程序
## HTML事件处理程序
特定元素支持的每个事件都可以使用事件处理程序的名字以HTML属性的形式来指定。 此时的属性值必须是能够执行的Javascript代码。如下
``` html
<input type="text" value="click me" onclick="console.log('clicked')">
```
因为属性的值是Javascript代码，所以不能在未经转义的情况下使用HTML语法字符，如&,",<,>等(其实是可以使用的，只是引号存在问题而已)。如果确实要使用这些字符，则需要改动代码为下例子
``` html
<input type="text" value="click me" onclick="console.log('&quot;clicked&quot')">
```
在HTML中定义的事件处理程序可以包含精确的动作指令，也可以调用在页面其他地方定义的脚本，比如：
``` js
<input type="text" onclick="showMessage()">
<script>
	function showMessage() {
		console.log('hello world');
	}
</script>
```
以这种方式指定的事件处理程序有一些特殊的地方。首先，会创建一个函数来封装属性的值。这个函数有一个特殊的局部变量event，其实保存的就是event对象
``` html
<!-- 输出click -->
<input type="text" onclick="console.log(event.type)"> 
```
有了这个对象，就不用开发者另外定义其他变量，也不用从包装函数的参数列表中去取了。

在这个函数中，this相当于事件的目标元素，如下所示：
``` html
<!-- 输出"Click Me" -->
<input type="button" value="Click Me" onclick="console.log(this.value)">
```
这个动态创建的包装函数还有一个特别有意思的地方，就是其作用域链被扩展了。在这个函数中，document和元素自身的成员都可以被当成局部变量来访问。这是通过使用with实现的：
``` js
function() {
	with(document){
		with(this){
			// 属性值 <- 事件对应的属性值
		}
	}
}
```
这意味着事件处理程序可以更方便地访问自己的属性。下面的代码于前面的示例功能一样：
``` html
<!-- 输出"Click Me" -->
<input type="button" value="Click Me " onclick="console.log(value)">
```
如果这个元素是一个表单输入框，则作用域中还会表单元素，事件处理程序对应的函数等价于如下：
``` js
function() {
	with(docuemnt){
		with(this.form) {
			with(this){
				// 属性值
			}
		}
	}
}
```
本质上，经过这样的扩展，事件处理程序的代码就不必应用表单元素，而直接访问同一表单中的其他成员了。如下
``` html
<form method="post">
	<!-- 打印button的value -->
	<input type="text" name="username" value="" onclick="console.log(button.value)">
	<!-- 打印上面的value -->
	<input type="button" value="Echo Username" onclick="console.log(username.value)" name="button">
</form>
```
在HTML中指定事件处理程序还有一些问题。第一个问题是时机问题。如HTML元素已经显示在页面上，且用户都交互了，但是事件处理程序还无法执行，此时就会发生错误。为此，大多数HTML事件处理程序会封装在try/catch块中，以便在这种情况下静默失败，如下例所示：
``` js
<script>
	function showMessage() {
		console.log('hello world');
	}
</script>
<input type="button" value="Click Me" onclick="try {showMessage()} catch(ex){}">
```
另一个问题对事件处理程序作用域链的扩展在不同浏览器中可能导致不同的结果。不同Javascript引擎中标识符解析的规则存在差异，因此访问无限定的对象成员可能导致错误。

使用HTML指定事件处理程序的最后一个问题是HTML与Javascript强耦合。使得修改事件处理程序，则必须修改两个地方。<-- 获取DOM，再添加事件，并没有方便太多吧。
## DOM0事件处理程序
在Javascript中指定处理程序的传统方式是把一个函数赋给DOM元素的一个事件处理程序属性。也就是通过获取操作对象后添加事件处理程序。如下
``` html
	<input type="button" id='myBtn' value="Click myBtn">
	<script>
		const btn = document.querySelector('#myBtn')
		btn.onclick = function () {
			console.log('click me');
		}
	</script>
```
需要注意的是，通过上诉的方法添加事件处理程序，需要在JavaScript代码运行后才会有效果。也就是说在用户点击按钮可能会出现没反应的情款，因为js代码还未运行。

像这样使用DOM0方式为事件处理程序赋值时，所附函数是为元素的方法。因此，事件处理程序会在元素的作用域中运行，即this等于元素。 以这种方式添加事件处理程序是注册在事件流的冒泡阶段。
``` html
	<form method="POST">
		<input type="text" value="value" name="input">
		<input type="button" id="myBtn2" value="click" name="button">
	</form>
	<script>
		const myBtn2 = document.querySelector('#myBtn2')
		myBtn2.onclick = function (event) {
			console.log(event);
			console.log(this); // input#myBtn2 element
			console.log(input.value); // 报错，这样就无法获取同一个form的其他元素了
		}
	</script>
```
通过将事件处理程序属性的值设置为null，可以移除通过DOM0方式添加的事件处理程序，如下
``` js
btn.onclick = null // 移除事件处理程序
```
> 如果事件处理程序实在HTML中指定的，则onclcick属性的值是一个包装相应HTML事件处理程序属性值的函数。这些事件处理程序也可以通过在JavaScript中将相应属性设置为null来移除。
## DOM2事件处理程序
DOM2 Events为事件处理程序的赋值和移除定义了两个方法：addEventLisener()remove-EventListener()。这两个方法暴露在所有DOM节点上，它们接受三个参数:事件名、事件处理程序、事件处理程序和一个布尔值，true表示在捕获阶段调用事件处理程序，false(默认值)表示在冒泡阶段调用事件处理程序。如下例：
``` html
	<input type="button" value="click me" id="btn3">
	<script>
		const btn3 = document.querySelector('#btn3')
		btn3.addEventListener('click', () => {
			console.log(this); // window
		})
		btn3.addEventListener('click', function () {
			console.log(this.id); // btn3
		})
	</script>
```
添加了两个事件处理程序，前面的会先触发，然后再打印"btn3"

通过addEventListener()添加的事件处理程序只能使用removeEventlistener()并传入与添加时相同的参数来移除。这意味着使用addEventListener()添加的匿名函数无法移除。如下
``` html
	<input type="button" value="removeEventListener" id="btn4">
	<script>
		const btn4 = document.querySelector('#btn4')
		btn4.addEventListener('click', function () {
			console.log(this.id);
		}, 'false')
		btn4.removeEventListener('click', function () { // 没有效果
			console.log(this.id);
		}, 'false')
	</script>
```
二者代码是相同的，当其实并不是同一个Function实例。若是要使用removeEventListener()，可以像如下代码：
``` html
<input type="button" value="removeEventListener correct" id="btn5">
<script>
	const btn5 = document.querySelector('#btn5')
	const hander = function () {
		console.log(this.id);
	}
	btn4.addEventListener('click', hander, 'false')
	btn4.removeEventListener('click', hander, 'false')
</script>
```
大多数情况下，事件处理程序会被添加至事件流的冒泡阶段，主要原因是跨跨浏览器兼容性好。把事件处理程序注册到捕获阶段通常用于在事件到达其指定目标之前拦截事件。如果不需要拦截，则不要使用事件捕获。
## IE事件处理程序
IE事件了与DOM类似的方法，即attachEvent()和detachEvent().这两个方法接受两个同样的参数：事件处理程序的名字和事件处理函数。因为IE8以及更早版本只支持事件冒泡，所以使用attachEvent()添加的事件处理程序会添加到冒泡阶段。
> 好像现代浏览器并不支持attachEvent方法,估计IE8以下才能使用此方法
``` html
	<input type="button" value="IE attachEvent" id='btn6'>
	<script>
		var btn6 = document.querySelector("#btn6")
		btn6.attachEvent('onclick', function () {
			console.log('click');
		})
	</script>
```
在IE中使用attachEvent()与使用DOM0方式的主要区别是事件处理程序的作用。使用DOM0方式时，事件处理程序中的this值等于目标元素。而使用attachEvent()，事件处理程序是在全局作用域中运行的，因此this等于window.
``` html
	<input type="button" value="this" id="btn">
	<script>
		var btn = document.getElementById('btn')
		btn.attachEvent('onclick', function () {
			console.log(this === window); // true
		})
	</script>
```
与addEventListener()一样，使用attachEvent()方法也可以给一个元素添加多个事件处理程序。有趣的是，与DOM方法不同，这里的事件处理程序会以添加它们的顺序方向触发。
``` html
	<input type="button" value="this" id="btn">
	<script>
		var btn = document.getElementById('btn')
		btn.attachEvent('onclick', function () {
			console.log(this === window); // true
		})
		btn.attachEvent('onclick', function () {
			console.log('define after');
		})
		// define after
		// click
	</script>
```
通过给detachEvent()提供相同参数，可以移除事件。
## 跨浏览器事件处理程序
为了以跨浏览器兼容的方式处理事件，可以通过能力检测，来进行处理。如下EventUtil对象，添加了跨浏览器的addHandler()和removeHandler()方法,同时为了使得事件处理的代码具有最大的兼容性，只需要让代码运行在冒泡阶段运行即可。
``` js
var EventUtil = {
	addHander:function(element,type,handler) {
		if(element.addEventListner) {
			element.addEventListner(type,handler,false)
		}else if(element.attachEvent) {
			element.attachEvent("on"+type,handler)
		}else {
			element["on"+type] = handler
		}
	},
	removeHandler:function(element,type,handler) {
		if(element.removeEventListenerl) {
			element.removeEventListenerl(type,handler,false)
		}else if(element.detachEvent) {
			element.detachEvent("on" + type,handler)
		}else {
			element["on"+type] = null
		}
	}
}
```
# 事件对象
DOM发生事件时，所有相关信息都会收集并存储在一个名为event的对象中。这个对象包含了一些基本信息。
## DOM事件对象
在DOM合规的浏览器中，event对象时传给事件处理程序的唯一参数。不管以哪种方式(DOM0或DOM2)指定事件处理程序，都会传入event对象。如下展示了两种方式下使用事件对象：
``` html
	<input type="button" id="btn" value="event object">
	<script>
		const btn = document.querySelector('#btn')
		btn.onclick = function (event) {
			console.log(event.type); // click
		}
		btn.addEventListener('click', (event) => {
			console.log(event.type); // click
		})
	</script>
```
当然在通过HTML属性指定的事件处理程序中，同样可以使用变量event应用事件对象
``` html
	<!-- 打印click -->
	<input type="button" value="event object html" onclick="console.log(event.type)"> 
```
如前所述，事件对象包含与特定事件相关的属性和方法。不同事件生成的事件对象也会包含不同的属性和方法。不过，所有事件对象都会包含下表列出的这些公共属性和方法。
![](index_files/20-1.png)

在事件处理程序内部，this对象始终等于currentTarget的值，而target只包含事件的实际目标。如果事件处理程序直接添加在了意图的目标。则this，currentTarget和target的值是一样的。如下例，三者就相等：
``` html
	<input type="button" value="this target currentTarget" id="btn2">
	<script>
		const btn2 = document.querySelector('#btn2')
		btn2.onclick = function (event) {
			console.log(event.target === this); // true
			console.log(event.currentTarget === this); // true
		}
	</script>
```
上面的代码检测了currentTarget和target的值是否等于this。因为click事件的目标是按钮，所以3个相等。如果这个事件处理程序是添加到按钮的父节点上，那么它们的值就不一样了。比如下面的例子在body上添加了单击处理程序
``` html
	<input type="button" value="this target currentTarget body" id="btn3">
	<script>
		const body = document.body
		body.onclick = function (event) {
			console.log(event.currentTarget === document.body);
			console.log(this === document.body);
			console.log(event.target === document.getElementById('btn3'));
		}
		// 在点击 btn3 后三个均打印 true
	</script>
```
在点击按钮后，this，currentTarget都等于document.body，这是因为他是注册事件处理程序的元素。而target属性等于按钮本身，这是因为那才是click事件真正的目标。由于按钮本身并没有注册事件处理程序，因此click事件冒泡到document.body,从而触发了在它上面注册的处理程序。

type属性在一个处理程序处理多个事件时很有用。比如下面的处理程序中就使用event.type:
``` html
	<input type="button" value="event.type" id="btn4">
	<script>
		const btn4 = document.getElementById("btn4")
		const handler = function (event) {
			switch (event.type) {
				case "click":
					console.log('Clicked');
					break
				case "mouseover":
					event.target.style.backgroundColor = "red"
					break
				case "mouseout":
					event.target.style.backgroundColor = ''
					break
			}
		}
		btn4.onclick = handler
		btn4.onmouseover = handler
		btn4.onmouseout = handler
	</script>
```
preventDefault()方法阻止特定事件的默认动作。比如，链接的默认行为就是在单击时被导航到href属性指定的URL。如果想阻止这个导航行为，可以在onclick事件处理程序中取消
``` js
	<a href="www.baidu.com" id="link">百度</a>
	<script>
		const link = document.getElementById('link')
		link.onclick = function (event) {
			event.preventDefault();
		}
	</script>
```
stopPropagation()方法用于立即阻止事件流在DOM结构中传播，取消后续事件捕获或冒泡。例如在前文body添加的事件的代码后，添加以下代码：
``` html
<!-- ...body的代码 --> 
	<input type="button" value="stop propagation" id="btn5">
	<script>
		const btn5 = document.getElementById('btn5')
		btn5.onclick = function (evnet) {
			console.log("clicked");
			evnet.stopPropagation(); //阻止了事件传播，body的click事件不会触发。
		}
	</script>
```
eventPhase属性可用于确定事件流当前所处的节点。如果事件处理程序在冒泡阶段被调用则，eventPhase等于1，如果事件处理程序在目标上被调用，则eventPhase等于2；如果事件处理程序在冒泡阶段被调用，则eventPhase等于3.不过要注意，虽然"到达目标"实在冒泡阶段发生的，但其eventPhase仍等于2. 如下：
> event对象旨在事件处理程序执行期间存在，一旦执行完毕，就会被销毁。
## IE事件对象
与DOM事件对象不同，IE事件对象可以基于事件处理程序被指定的方式以不同的方式来访问。如果事件处理程序是使用DOM0方式指定的，则event对象只是window对象的一个属性(看样子其他浏览器中也会在window中存event)，如下所示：
``` html
	<input type="button" value="click" id="btn">
	<script>
		var btn = document.getElementById('btn')
		btn.onclick = function () {
			const event = window.event
			console.log(event.type); // click
		}
	</script>
```
若是事件处理程序是使用attachEvent()指定的，则event对象会作为唯一的参数传给处理函数，如下所示：
``` html
	<input type="button" value="click attach" id="btn2">
	<script>
		var btn2 = document.getElementById('btn2')
		btn2.attachEvent('onclick', function (event) {
			console.log(event.type);
		})
	</script>
```
使用attachEvent()，event对象仍然是window对象的属性，只是出于方便也将其作为参数传入。

如果使用HTML属性方式指定事件的事件处理程序，则event对象同样可以通过变量event访问。
``` html
<input type="button" value="HTML" onclick="console.log(event.type)">
```
IE事件对象也包含导致其创建特定事件相关的属性和方法，其中很多与相关的DOM属性和方法对应。与DOM事件对象一样，基于触发的事件类型不同，event对象中包含的属性和方法也不一样。 不过所有IE事件对象都会包含下列公共属性和方法
![](index_files/20-2.png)

由于事件处理程序的作用域取决于指定它的方式，因此this值并不总是等于事件目标。为此更好的方式是使用事件对象的srcElement属性代替this。下面的例子表明，不同事件对象上的srcElement属性中保存的都是事件目标：
``` html
	<input type="button" value="srcElement" id="btn3">
	<script>
		var btn3 = document.getElementById('btn3')
		btn3.onclick = function () {
			console.log(window.event.srcElement === this); // true
		}
		btn3.attachEvent("onclick", function (event) {
			console.log(window.event.srcElement === this); // false
		})
	</script>
```
returnValue属性等价于DOM preveDefault()方法，都是用于取消给定事件默认的行为。只不过这里是设置returnValue的值为false。
``` js
	<a href="https://www.baidu.com" id="link">百度</a>
	<script>
		var link = document.querySelector('#link')
		link.onclick = function () {
			window.event.returnValue = false
		}
	</script>
```
cancelBubble属性与DOMstopPropagation()方法的用途相同，都可以阻止事件冒泡。因为IE8之前不支持捕获阶段，因此只会前者只会取消冒泡。而后者机会取消捕获也会取消冒泡
``` html
	<input type="button" value="cancelBubbte" id="btn4">
	<script>
		var btn4 = document.querySelector('#btn4')
		btn4.onclick = function () {
			console.log("clicked");
			window.event.cancelBubble = true
		}
		document.body.onclick = function () {
			console.log('body clicked');
		}
	</script>
```
## 跨浏览器事件对象
虽然DOM与IE的事件对象并不相同，但它们有足够的相似性来实现跨浏览器方案。DOM事件对象中包含IE事件对象的所有信息和能力。本章之前的EventUtil对象可以像下面一样再添加一些方法
``` js
var EventUtil = {
	//... 之前的代码
	getEvent: function (event) {
		return event ? event : window.event
	},
	getTarget:function(event) {
		return event.target || event.srcElement
	},
	preventDefault: function(event) {
		if(event.preventDefault) {
			event.preventDefault
		}else {
			event.returnValue = false
		}
	},
	stopPropagation:function(event) {
		if(event.stopPropagation){
			event.stopPropagation()
		}else {
			event.cancelBubble = true
		}
	}
}
```
# 事件类型
DOM3 Events定义了如下事件类型:
+ 用户界面事件(UIEvent):涉及与BOM交互的通用浏览器事件。
+ 焦点事件(FocusEvent):再元素获得和失去焦点时触发。
+ 鼠标事件(MouseEvent):使用鼠标在页面上执行某些操作时触发。
+ 滚轮事件(WheelEvent):使用鼠标滚轮(或类似设备)时触发。
+ 输入事件(InputEvent):像文档中输入文本时触发。
+ 键盘事件(KeyBoardEvent):使用键盘在页面上执行某些操作时触发.
+ 合成事件(compositionEvent):在使用某种IME(input Method Editor,输入法编辑器)输入字符时触发。

除了以上这些事件类型外，HTML5还定义了另一组事件，而浏览器通常在DOM和BOM上实现专有事件。
## 用户界面事件
用户界面时间或UI事件不一定与用户操作有关。这类事件在DOM规范出现之前，就已经以某种形式存在了，保留它们是为了向后兼容。UI事件主要有以下几种：
+ DOMActivate: 有元素被用户通过鼠标或键盘操作激活时触发(比click或keydown更加通用).这个事件在DOM3 Events中被废弃。因为浏览器实现之间存在差异，所以不要使用它。
+ load:在window上当页面加载完成后触发，在窗套(<frameset\>)上当所有窗格(<frame\>)都加载完毕后触发，在<img\>元素上当图片加载完成后触发，在<object\>元素上当对应对象加载完毕后触发。
+ unload: 在window上当页面完全卸载后触发，在<frameset\>上所有<frame\>都卸载完成后触发，在<object\>元素上相应对象卸载完毕后触发。
+ abord: 在<object\>元素上当相应对象加载完成前被用户提前终止下载时触发。
+ error: 在window上当Javascript报错时触发，在<img\>元素上当无法加载指定图片时触发，在<object\>元素上无法加载响应对象时触发，在<framset\>上一个或多个<frame\>无法完成加载时触发。
+ select: 在文本框(<input\>或textarea)上当用户选择了一个或多个字符时触发。
+ resize: 在window或窗格上窗口或窗格被缩放时触发
+ scroll: 当用户滚动包含滚动条的元素时在元素上触发。<body\>元素包含已加载页面的滚动条。

大多数HTML事件都与window对象和表单控件有关。

除了DOMActivate，这些事件在DOM2 Event中都被归为HTML Events
### load事件
在window对象上load事件会在整个页面(包括所有外部资源如图片，Javascript和CSS文件)加载完成后触发。可以通过两种方式指定load事件处理程序。第一种是Javascript方式
``` js
window.addEventListener('load', () => {
	console.log('loaded');
})
```
使用上诉方法，事件处理程序会接受到一个event对象。这个对象没有提供关于这个类型事件的额外信息，虽然在DOM合规的浏览器中，event.target会被设置为document，但在IE8之前的版本中，不会设置这个对象的srcElement属性。

第二种指定load事件处理程序的方式是向<body\>元素添加onload属性，如下所示：
``` html
<body onload="console.log('loaded')"></body>
```
> 根据DOM2 Event，load事件应该在document而非window上触发，但是为了向后兼容，所有浏览器都在window上实现了load事件。

图片也会触发load事件，包括DOM中的图片和非DOM中的图片。可以在HTML中指定onload属性
``` html
<img src="./smile.png" onload="console.log('image loaded')">
```
该例子会在图片加载完毕后输出一条消息，同样也可以使用addEventListener()指定处理程序, 需要确保页面已经加载完毕再进行操作，否则在加载之前进行操作document.body会报错。需要注意的是，下载图片并不一定要将图片添加到DOM，只要设置src属性就会立即开始下载了。 这里关键是要在赋值src属性前指定事件处理程序 <-- 看上去并不需要呀，在赋值之后再添加事件处理程序也行呀？
``` js
window.addEventListener('load', () => {
	console.log('loaded');
	const image = document.createElement('img')
	document.body.appendChild(image)
	image.addEventListener('load', (event) => {
		console.log(event.target.src);
	})
	image.src = './smile.png'
})
```
同样的技术也适用于DOM0的image对象。在DOM出现之前，客户端都使用image对象也先加载图片。 可以像使用前面的<img\>元素使用Image对象，只是不能把后者添加到DOM树。下面的例子使用新Image对象实现了图片预加载 <-- 如果不能添加的话，有什么意义呢？：
``` js
window.addEventListener('load', () => {
	let img = new Image()
	img.addEventListener('load', () => {
		console.log('new Image loaded');
	})
	img.src = './smile.png'
})
```
有些浏览器会把Image对象实现为<img\>元素，但并非所有浏览器都是如此。
> 在IE8或早期版本中，如果图片没有添加到DOM文档中了，则load事件发生时不会生成event对象。对未添加到文档中的<img\>元素以及image对象来说都是如此。
还有一些元素也以非标准的方式支持load事件。<script\>元素会在Javascript文件加载完成后触发load事件，从而可以动态监测。要下载JavaScript文件必须同时指定src属性，并添加到文档中。因此指定事件处理程序和指定src属性的顺序并不重要。
``` js
window.addEventListener('load', () => {
	const script = document.createElement('script')
	script.addEventListener('load', (event) => {
		console.log('loaded');
	})
	script.src = "./06-example.js"
	document.body.appendChild(script)
})
```
这里的event对象的target属性在大多数浏览器中是<scirpt\>节点。IE8及更早的版本的不支持<scirpt\>触发load事件。

IE和Opera支持<link\>元素触发load事件，因此支持动态检测样式表是否加载完成。同<script\>标签相同，在指定href属性，并添加到文档之前不会下载样式表(若是没有添加rel属性，也不会下载样式表)
``` js
window.addEventListener('load', () => {
	const link = document.createElement('link')
	link.type = "text/css"
	link.rel = "stylesheet"
	link.addEventListener('load', (event) => {
		console.log('outside css loaded');
	})
	link.href = './07-example.css'
	document.getElementsByTagName('head')[0].appendChild(link)
})
```
### unload事件
与load事件相对应的是unload事件，unload事件会在文档卸载完成后触发。unload事件一般是从一个页面导航到另一个页面时触发，最常用于清理引用，以免内存泄漏。 <--刷新就可以看到了，就一瞬间,但是发生页面跳转的时候，似乎是无法看到的。
``` js
window.addEventListener('unload', (event) => {
	console.log('Unloaded!');
})
```
第二种方式是通过给body添加onunload属性
``` js
<body onload="console.log('loaded')" onunload="console.log('body unload')">
```
无论以上哪种方式，在处理程序中，都不能使用页面加载后才有的对象，此时访问DOM或修改页面外观都会导致报错。<--不知道为啥无法使用window.open()
### resize事件
当浏览器窗口被缩放到新高度或宽度时，会触发resize事件。这个事件在window上触发，因此可以通过Javascript在window上，或者为body添加onresize属性来指定事件处理程序。
``` js
window.addEventListener('resize', (event) => {
	console.log('Resized');
})
```
类似于在其他window上发生的事件，此时会生成event对象，且这个对象的target属性时document。

最好不要在这个事件中执行过多计算，否则可能会由于执行过于频繁而导致浏览器相应变慢。
> 浏览器在最大化和最小化时也会触发resize事件。
### scroll事件
scroll事件发生window上，但实际上反映的是页面中相应元素的变化。混则模式下，可以通过<boody\>元素检测scrollLeft和scrollTop属性的变化。而在标准模式下，这些变化发生在<html\>上(除早期Safari以外)。下面的代码演示如何处理这些差异：
``` js
window.addEventListener('scroll', (event) => {
	if (document.compatMode == 'CSS1Compat') {
		console.log(document.documentElement.scrollTop);
	} else {
		console.log(document.body.scrollTop);
	}
})
```
## 焦点事件