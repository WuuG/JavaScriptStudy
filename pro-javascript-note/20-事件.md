- [事件流](#事件流)
	- [事件冒泡](#事件冒泡)
	- [事件捕获](#事件捕获)
	- [DOM事件流](#dom事件流)
- [事件处理程序](#事件处理程序)
	- [HTML事件处理程序](#html事件处理程序)
	- [DOM0事件处理程序](#dom0事件处理程序)
	- [DOM2事件处理程序](#dom2事件处理程序)
	- [IE事件处理程序](#ie事件处理程序)
	- [跨浏览器事件处理程序](#跨浏览器事件处理程序)
- [事件对象](#事件对象)
	- [DOM事件对象](#dom事件对象)
	- [IE事件对象](#ie事件对象)
	- [跨浏览器事件对象](#跨浏览器事件对象)
- [事件类型](#事件类型)
	- [用户界面事件](#用户界面事件)
		- [load事件](#load事件)
		- [unload事件](#unload事件)
		- [resize事件](#resize事件)
		- [scroll事件](#scroll事件)
	- [焦点事件](#焦点事件)
	- [鼠标和滚轮事件](#鼠标和滚轮事件)
		- [客户端坐标](#客户端坐标)
		- [页面坐标](#页面坐标)
		- [屏幕坐标](#屏幕坐标)
		- [修饰键](#修饰键)
		- [相关元素](#相关元素)
		- [鼠标按键](#鼠标按键)
		- [额外事件](#额外事件)
		- [mousewheel事件](#mousewheel事件)
		- [触摸屏设备](#触摸屏设备)
		- [无障碍问题](#无障碍问题)
	- [键盘于输入事件](#键盘于输入事件)
		- [键码](#键码)
		- [字符编码](#字符编码)
		- [DOM3 的变化](#dom3-的变化)
# 事件流
事件冒泡和事件捕获流。 完全相反的两种事件接受的方法
## 事件冒泡
事件从最具体的元素(文档中最深的节点)开始触发，初步向上传播.如下代码，在点击div后会逐步向上传播div->body->html->document
``` html
<html lang="en">
<body>
	<div></div>
</body>
</html>
```
所有现代浏览器都支持事件冒泡，只是在实现方式上会有一些变化。早期IE会跳过html。而现代浏览器中的事件会一直冒泡到window对象
## 事件捕获
事件捕获恰好与事件冒泡相反，最不具体的元素先收到事件，最具体的元素后收到事件。如上代码则会从document->html->body->div的顺序传播。

现代浏览器均支持事件捕获。实际上所有的浏览器都是从window对象开始捕获事件的，而DOM2 Events规范规定从document开始。

> 由于旧版本浏览器不支持，因此实际中几乎不会使用事件捕获。通常建议使用事件冒泡，特殊情况下使用事件捕获。
## DOM事件流
DOM2 Events规范规定事件流分为3个阶段：事件捕获、到达目标和事件冒泡。事件捕获最先发生，未提前拦截事件提供可能。 然后实际的目标元素接受到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。

如前文例子，在事件捕获阶段document-> html -> body 传播，注意在该阶段实际的目标元素(本例中是div)不会接受到事件。下一阶段，也就是div触发事件时，通常会被认为是冒泡阶段的一部分。

大多数支持DOM事件流的浏览器实现了一个小小的拓展。虽然DOM2 Events规范明确捕获阶段不命中事件目标。但现在浏览器都会在捕获阶段在事件目标上触发事件。最终结果是在事件目标上有两个机会来处理事件。
# 事件处理程序
## HTML事件处理程序
特定元素支持的每个事件都可以使用事件处理程序的名字以HTML属性的形式来指定。 此时的属性值必须是能够执行的Javascript代码。如下
``` html
<input type="text" value="click me" onclick="console.log('clicked')">
```
因为属性的值是Javascript代码，所以不能在未经转义的情况下使用HTML语法字符，如&,",<,>等(其实是可以使用的，只是引号存在问题而已)。如果确实要使用这些字符，则需要改动代码为下例子
``` html
<input type="text" value="click me" onclick="console.log('&quot;clicked&quot')">
```
在HTML中定义的事件处理程序可以包含精确的动作指令，也可以调用在页面其他地方定义的脚本，比如：
``` js
<input type="text" onclick="showMessage()">
<script>
	function showMessage() {
		console.log('hello world');
	}
</script>
```
以这种方式指定的事件处理程序有一些特殊的地方。首先，会创建一个函数来封装属性的值。这个函数有一个特殊的局部变量event，其实保存的就是event对象
``` html
<!-- 输出click -->
<input type="text" onclick="console.log(event.type)"> 
```
有了这个对象，就不用开发者另外定义其他变量，也不用从包装函数的参数列表中去取了。

在这个函数中，this相当于事件的目标元素，如下所示：
``` html
<!-- 输出"Click Me" -->
<input type="button" value="Click Me" onclick="console.log(this.value)">
```
这个动态创建的包装函数还有一个特别有意思的地方，就是其作用域链被扩展了。在这个函数中，document和元素自身的成员都可以被当成局部变量来访问。这是通过使用with实现的：
``` js
function() {
	with(document){
		with(this){
			// 属性值 <- 事件对应的属性值
		}
	}
}
```
这意味着事件处理程序可以更方便地访问自己的属性。下面的代码于前面的示例功能一样：
``` html
<!-- 输出"Click Me" -->
<input type="button" value="Click Me " onclick="console.log(value)">
```
如果这个元素是一个表单输入框，则作用域中还会表单元素，事件处理程序对应的函数等价于如下：
``` js
function() {
	with(docuemnt){
		with(this.form) {
			with(this){
				// 属性值
			}
		}
	}
}
```
本质上，经过这样的扩展，事件处理程序的代码就不必应用表单元素，而直接访问同一表单中的其他成员了。如下
``` html
<form method="post">
	<!-- 打印button的value -->
	<input type="text" name="username" value="" onclick="console.log(button.value)">
	<!-- 打印上面的value -->
	<input type="button" value="Echo Username" onclick="console.log(username.value)" name="button">
</form>
```
在HTML中指定事件处理程序还有一些问题。第一个问题是时机问题。如HTML元素已经显示在页面上，且用户都交互了，但是事件处理程序还无法执行，此时就会发生错误。为此，大多数HTML事件处理程序会封装在try/catch块中，以便在这种情况下静默失败，如下例所示：
``` js
<script>
	function showMessage() {
		console.log('hello world');
	}
</script>
<input type="button" value="Click Me" onclick="try {showMessage()} catch(ex){}">
```
另一个问题对事件处理程序作用域链的扩展在不同浏览器中可能导致不同的结果。不同Javascript引擎中标识符解析的规则存在差异，因此访问无限定的对象成员可能导致错误。

使用HTML指定事件处理程序的最后一个问题是HTML与Javascript强耦合。使得修改事件处理程序，则必须修改两个地方。<-- 获取DOM，再添加事件，并没有方便太多吧。
## DOM0事件处理程序
在Javascript中指定处理程序的传统方式是把一个函数赋给DOM元素的一个事件处理程序属性。也就是通过获取操作对象后添加事件处理程序。如下
``` html
	<input type="button" id='myBtn' value="Click myBtn">
	<script>
		const btn = document.querySelector('#myBtn')
		btn.onclick = function () {
			console.log('click me');
		}
	</script>
```
需要注意的是，通过上诉的方法添加事件处理程序，需要在JavaScript代码运行后才会有效果。也就是说在用户点击按钮可能会出现没反应的情款，因为js代码还未运行。

像这样使用DOM0方式为事件处理程序赋值时，所附函数是为元素的方法。因此，事件处理程序会在元素的作用域中运行，即this等于元素。 以这种方式添加事件处理程序是注册在事件流的冒泡阶段。
``` html
	<form method="POST">
		<input type="text" value="value" name="input">
		<input type="button" id="myBtn2" value="click" name="button">
	</form>
	<script>
		const myBtn2 = document.querySelector('#myBtn2')
		myBtn2.onclick = function (event) {
			console.log(event);
			console.log(this); // input#myBtn2 element
			console.log(input.value); // 报错，这样就无法获取同一个form的其他元素了
		}
	</script>
```
通过将事件处理程序属性的值设置为null，可以移除通过DOM0方式添加的事件处理程序，如下
``` js
btn.onclick = null // 移除事件处理程序
```
> 如果事件处理程序实在HTML中指定的，则onclcick属性的值是一个包装相应HTML事件处理程序属性值的函数。这些事件处理程序也可以通过在JavaScript中将相应属性设置为null来移除。
## DOM2事件处理程序
DOM2 Events为事件处理程序的赋值和移除定义了两个方法：addEventLisener()remove-EventListener()。这两个方法暴露在所有DOM节点上，它们接受三个参数:事件名、事件处理程序、事件处理程序和一个布尔值，true表示在捕获阶段调用事件处理程序，false(默认值)表示在冒泡阶段调用事件处理程序。如下例：
``` html
	<input type="button" value="click me" id="btn3">
	<script>
		const btn3 = document.querySelector('#btn3')
		btn3.addEventListener('click', () => {
			console.log(this); // window
		})
		btn3.addEventListener('click', function () {
			console.log(this.id); // btn3
		})
	</script>
```
添加了两个事件处理程序，前面的会先触发，然后再打印"btn3"

通过addEventListener()添加的事件处理程序只能使用removeEventlistener()并传入与添加时相同的参数来移除。这意味着使用addEventListener()添加的匿名函数无法移除。如下
``` html
	<input type="button" value="removeEventListener" id="btn4">
	<script>
		const btn4 = document.querySelector('#btn4')
		btn4.addEventListener('click', function () {
			console.log(this.id);
		}, 'false')
		btn4.removeEventListener('click', function () { // 没有效果
			console.log(this.id);
		}, 'false')
	</script>
```
二者代码是相同的，当其实并不是同一个Function实例。若是要使用removeEventListener()，可以像如下代码：
``` html
<input type="button" value="removeEventListener correct" id="btn5">
<script>
	const btn5 = document.querySelector('#btn5')
	const hander = function () {
		console.log(this.id);
	}
	btn4.addEventListener('click', hander, 'false')
	btn4.removeEventListener('click', hander, 'false')
</script>
```
大多数情况下，事件处理程序会被添加至事件流的冒泡阶段，主要原因是跨跨浏览器兼容性好。把事件处理程序注册到捕获阶段通常用于在事件到达其指定目标之前拦截事件。如果不需要拦截，则不要使用事件捕获。
## IE事件处理程序
IE事件了与DOM类似的方法，即attachEvent()和detachEvent().这两个方法接受两个同样的参数：事件处理程序的名字和事件处理函数。因为IE8以及更早版本只支持事件冒泡，所以使用attachEvent()添加的事件处理程序会添加到冒泡阶段。
> 好像现代浏览器并不支持attachEvent方法,估计IE8以下才能使用此方法
``` html
	<input type="button" value="IE attachEvent" id='btn6'>
	<script>
		var btn6 = document.querySelector("#btn6")
		btn6.attachEvent('onclick', function () {
			console.log('click');
		})
	</script>
```
在IE中使用attachEvent()与使用DOM0方式的主要区别是事件处理程序的作用。使用DOM0方式时，事件处理程序中的this值等于目标元素。而使用attachEvent()，事件处理程序是在全局作用域中运行的，因此this等于window.
``` html
	<input type="button" value="this" id="btn">
	<script>
		var btn = document.getElementById('btn')
		btn.attachEvent('onclick', function () {
			console.log(this === window); // true
		})
	</script>
```
与addEventListener()一样，使用attachEvent()方法也可以给一个元素添加多个事件处理程序。有趣的是，与DOM方法不同，这里的事件处理程序会以添加它们的顺序方向触发。
``` html
	<input type="button" value="this" id="btn">
	<script>
		var btn = document.getElementById('btn')
		btn.attachEvent('onclick', function () {
			console.log(this === window); // true
		})
		btn.attachEvent('onclick', function () {
			console.log('define after');
		})
		// define after
		// click
	</script>
```
通过给detachEvent()提供相同参数，可以移除事件。
## 跨浏览器事件处理程序
为了以跨浏览器兼容的方式处理事件，可以通过能力检测，来进行处理。如下EventUtil对象，添加了跨浏览器的addHandler()和removeHandler()方法,同时为了使得事件处理的代码具有最大的兼容性，只需要让代码运行在冒泡阶段运行即可。
``` js
var EventUtil = {
	addHander:function(element,type,handler) {
		if(element.addEventListner) {
			element.addEventListner(type,handler,false)
		}else if(element.attachEvent) {
			element.attachEvent("on"+type,handler)
		}else {
			element["on"+type] = handler
		}
	},
	removeHandler:function(element,type,handler) {
		if(element.removeEventListenerl) {
			element.removeEventListenerl(type,handler,false)
		}else if(element.detachEvent) {
			element.detachEvent("on" + type,handler)
		}else {
			element["on"+type] = null
		}
	}
}
```
# 事件对象
DOM发生事件时，所有相关信息都会收集并存储在一个名为event的对象中。这个对象包含了一些基本信息。
## DOM事件对象
在DOM合规的浏览器中，event对象时传给事件处理程序的唯一参数。不管以哪种方式(DOM0或DOM2)指定事件处理程序，都会传入event对象。如下展示了两种方式下使用事件对象：
``` html
	<input type="button" id="btn" value="event object">
	<script>
		const btn = document.querySelector('#btn')
		btn.onclick = function (event) {
			console.log(event.type); // click
		}
		btn.addEventListener('click', (event) => {
			console.log(event.type); // click
		})
	</script>
```
当然在通过HTML属性指定的事件处理程序中，同样可以使用变量event应用事件对象
``` html
	<!-- 打印click -->
	<input type="button" value="event object html" onclick="console.log(event.type)"> 
```
如前所述，事件对象包含与特定事件相关的属性和方法。不同事件生成的事件对象也会包含不同的属性和方法。不过，所有事件对象都会包含下表列出的这些公共属性和方法。
![](index_files/20-1.png)

在事件处理程序内部，this对象始终等于currentTarget的值，而target只包含事件的实际目标。如果事件处理程序直接添加在了意图的目标。则this，currentTarget和target的值是一样的。如下例，三者就相等：
``` html
	<input type="button" value="this target currentTarget" id="btn2">
	<script>
		const btn2 = document.querySelector('#btn2')
		btn2.onclick = function (event) {
			console.log(event.target === this); // true
			console.log(event.currentTarget === this); // true
		}
	</script>
```
上面的代码检测了currentTarget和target的值是否等于this。因为click事件的目标是按钮，所以3个相等。如果这个事件处理程序是添加到按钮的父节点上，那么它们的值就不一样了。比如下面的例子在body上添加了单击处理程序
``` html
	<input type="button" value="this target currentTarget body" id="btn3">
	<script>
		const body = document.body
		body.onclick = function (event) {
			console.log(event.currentTarget === document.body);
			console.log(this === document.body);
			console.log(event.target === document.getElementById('btn3'));
		}
		// 在点击 btn3 后三个均打印 true
	</script>
```
在点击按钮后，this，currentTarget都等于document.body，这是因为他是注册事件处理程序的元素。而target属性等于按钮本身，这是因为那才是click事件真正的目标。由于按钮本身并没有注册事件处理程序，因此click事件冒泡到document.body,从而触发了在它上面注册的处理程序。

type属性在一个处理程序处理多个事件时很有用。比如下面的处理程序中就使用event.type:
``` html
	<input type="button" value="event.type" id="btn4">
	<script>
		const btn4 = document.getElementById("btn4")
		const handler = function (event) {
			switch (event.type) {
				case "click":
					console.log('Clicked');
					break
				case "mouseover":
					event.target.style.backgroundColor = "red"
					break
				case "mouseout":
					event.target.style.backgroundColor = ''
					break
			}
		}
		btn4.onclick = handler
		btn4.onmouseover = handler
		btn4.onmouseout = handler
	</script>
```
preventDefault()方法阻止特定事件的默认动作。比如，链接的默认行为就是在单击时被导航到href属性指定的URL。如果想阻止这个导航行为，可以在onclick事件处理程序中取消
``` js
	<a href="www.baidu.com" id="link">百度</a>
	<script>
		const link = document.getElementById('link')
		link.onclick = function (event) {
			event.preventDefault();
		}
	</script>
```
stopPropagation()方法用于立即阻止事件流在DOM结构中传播，取消后续事件捕获或冒泡。例如在前文body添加的事件的代码后，添加以下代码：
``` html
<!-- ...body的代码 --> 
	<input type="button" value="stop propagation" id="btn5">
	<script>
		const btn5 = document.getElementById('btn5')
		btn5.onclick = function (evnet) {
			console.log("clicked");
			evnet.stopPropagation(); //阻止了事件传播，body的click事件不会触发。
		}
	</script>
```
eventPhase属性可用于确定事件流当前所处的节点。如果事件处理程序在冒泡阶段被调用则，eventPhase等于1，如果事件处理程序在目标上被调用，则eventPhase等于2；如果事件处理程序在冒泡阶段被调用，则eventPhase等于3.不过要注意，虽然"到达目标"实在冒泡阶段发生的，但其eventPhase仍等于2. 如下：
> event对象旨在事件处理程序执行期间存在，一旦执行完毕，就会被销毁。
## IE事件对象
与DOM事件对象不同，IE事件对象可以基于事件处理程序被指定的方式以不同的方式来访问。如果事件处理程序是使用DOM0方式指定的，则event对象只是window对象的一个属性(看样子其他浏览器中也会在window中存event)，如下所示：
``` html
	<input type="button" value="click" id="btn">
	<script>
		var btn = document.getElementById('btn')
		btn.onclick = function () {
			const event = window.event
			console.log(event.type); // click
		}
	</script>
```
若是事件处理程序是使用attachEvent()指定的，则event对象会作为唯一的参数传给处理函数，如下所示：
``` html
	<input type="button" value="click attach" id="btn2">
	<script>
		var btn2 = document.getElementById('btn2')
		btn2.attachEvent('onclick', function (event) {
			console.log(event.type);
		})
	</script>
```
使用attachEvent()，event对象仍然是window对象的属性，只是出于方便也将其作为参数传入。

如果使用HTML属性方式指定事件的事件处理程序，则event对象同样可以通过变量event访问。
``` html
<input type="button" value="HTML" onclick="console.log(event.type)">
```
IE事件对象也包含导致其创建特定事件相关的属性和方法，其中很多与相关的DOM属性和方法对应。与DOM事件对象一样，基于触发的事件类型不同，event对象中包含的属性和方法也不一样。 不过所有IE事件对象都会包含下列公共属性和方法
![](index_files/20-2.png)

由于事件处理程序的作用域取决于指定它的方式，因此this值并不总是等于事件目标。为此更好的方式是使用事件对象的srcElement属性代替this。下面的例子表明，不同事件对象上的srcElement属性中保存的都是事件目标：
``` html
	<input type="button" value="srcElement" id="btn3">
	<script>
		var btn3 = document.getElementById('btn3')
		btn3.onclick = function () {
			console.log(window.event.srcElement === this); // true
		}
		btn3.attachEvent("onclick", function (event) {
			console.log(window.event.srcElement === this); // false
		})
	</script>
```
returnValue属性等价于DOM preveDefault()方法，都是用于取消给定事件默认的行为。只不过这里是设置returnValue的值为false。
``` js
	<a href="https://www.baidu.com" id="link">百度</a>
	<script>
		var link = document.querySelector('#link')
		link.onclick = function () {
			window.event.returnValue = false
		}
	</script>
```
cancelBubble属性与DOMstopPropagation()方法的用途相同，都可以阻止事件冒泡。因为IE8之前不支持捕获阶段，因此只会前者只会取消冒泡。而后者机会取消捕获也会取消冒泡
``` html
	<input type="button" value="cancelBubbte" id="btn4">
	<script>
		var btn4 = document.querySelector('#btn4')
		btn4.onclick = function () {
			console.log("clicked");
			window.event.cancelBubble = true
		}
		document.body.onclick = function () {
			console.log('body clicked');
		}
	</script>
```
## 跨浏览器事件对象
虽然DOM与IE的事件对象并不相同，但它们有足够的相似性来实现跨浏览器方案。DOM事件对象中包含IE事件对象的所有信息和能力。本章之前的EventUtil对象可以像下面一样再添加一些方法
``` js
var EventUtil = {
	//... 之前的代码
	getEvent: function (event) {
		return event ? event : window.event
	},
	getTarget:function(event) {
		return event.target || event.srcElement
	},
	preventDefault: function(event) {
		if(event.preventDefault) {
			event.preventDefault
		}else {
			event.returnValue = false
		}
	},
	stopPropagation:function(event) {
		if(event.stopPropagation){
			event.stopPropagation()
		}else {
			event.cancelBubble = true
		}
	}
}
```
# 事件类型
DOM3 Events定义了如下事件类型:
+ 用户界面事件(UIEvent):涉及与BOM交互的通用浏览器事件。
+ 焦点事件(FocusEvent):再元素获得和失去焦点时触发。
+ 鼠标事件(MouseEvent):使用鼠标在页面上执行某些操作时触发。
+ 滚轮事件(WheelEvent):使用鼠标滚轮(或类似设备)时触发。
+ 输入事件(InputEvent):像文档中输入文本时触发。
+ 键盘事件(KeyBoardEvent):使用键盘在页面上执行某些操作时触发.
+ 合成事件(compositionEvent):在使用某种IME(input Method Editor,输入法编辑器)输入字符时触发。

除了以上这些事件类型外，HTML5还定义了另一组事件，而浏览器通常在DOM和BOM上实现专有事件。
## 用户界面事件
用户界面时间或UI事件不一定与用户操作有关。这类事件在DOM规范出现之前，就已经以某种形式存在了，保留它们是为了向后兼容。UI事件主要有以下几种：
+ DOMActivate: 有元素被用户通过鼠标或键盘操作激活时触发(比click或keydown更加通用).这个事件在DOM3 Events中被废弃。因为浏览器实现之间存在差异，所以不要使用它。
+ load:在window上当页面加载完成后触发，在窗套(<frameset\>)上当所有窗格(<frame\>)都加载完毕后触发，在<img\>元素上当图片加载完成后触发，在<object\>元素上当对应对象加载完毕后触发。
+ unload: 在window上当页面完全卸载后触发，在<frameset\>上所有<frame\>都卸载完成后触发，在<object\>元素上相应对象卸载完毕后触发。
+ abord: 在<object\>元素上当相应对象加载完成前被用户提前终止下载时触发。
+ error: 在window上当Javascript报错时触发，在<img\>元素上当无法加载指定图片时触发，在<object\>元素上无法加载响应对象时触发，在<framset\>上一个或多个<frame\>无法完成加载时触发。
+ select: 在文本框(<input\>或textarea)上当用户选择了一个或多个字符时触发。
+ resize: 在window或窗格上窗口或窗格被缩放时触发
+ scroll: 当用户滚动包含滚动条的元素时在元素上触发。<body\>元素包含已加载页面的滚动条。

大多数HTML事件都与window对象和表单控件有关。

除了DOMActivate，这些事件在DOM2 Event中都被归为HTML Events
### load事件
在window对象上load事件会在整个页面(包括所有外部资源如图片，Javascript和CSS文件)加载完成后触发。可以通过两种方式指定load事件处理程序。第一种是Javascript方式
``` js
window.addEventListener('load', () => {
	console.log('loaded');
})
```
使用上诉方法，事件处理程序会接受到一个event对象。这个对象没有提供关于这个类型事件的额外信息，虽然在DOM合规的浏览器中，event.target会被设置为document，但在IE8之前的版本中，不会设置这个对象的srcElement属性。

第二种指定load事件处理程序的方式是向<body\>元素添加onload属性，如下所示：
``` html
<body onload="console.log('loaded')"></body>
```
> 根据DOM2 Event，load事件应该在document而非window上触发，但是为了向后兼容，所有浏览器都在window上实现了load事件。

图片也会触发load事件，包括DOM中的图片和非DOM中的图片。可以在HTML中指定onload属性
``` html
<img src="./smile.png" onload="console.log('image loaded')">
```
该例子会在图片加载完毕后输出一条消息，同样也可以使用addEventListener()指定处理程序, 需要确保页面已经加载完毕再进行操作，否则在加载之前进行操作document.body会报错。需要注意的是，下载图片并不一定要将图片添加到DOM，只要设置src属性就会立即开始下载了。 这里关键是要在赋值src属性前指定事件处理程序 <-- 看上去并不需要呀，在赋值之后再添加事件处理程序也行呀？
``` js
window.addEventListener('load', () => {
	console.log('loaded');
	const image = document.createElement('img')
	document.body.appendChild(image)
	image.addEventListener('load', (event) => {
		console.log(event.target.src);
	})
	image.src = './smile.png'
})
```
同样的技术也适用于DOM0的image对象。在DOM出现之前，客户端都使用image对象也先加载图片。 可以像使用前面的<img\>元素使用Image对象，只是不能把后者添加到DOM树。下面的例子使用新Image对象实现了图片预加载 <-- 如果不能添加的话，有什么意义呢？：
``` js
window.addEventListener('load', () => {
	let img = new Image()
	img.addEventListener('load', () => {
		console.log('new Image loaded');
	})
	img.src = './smile.png'
})
```
有些浏览器会把Image对象实现为<img\>元素，但并非所有浏览器都是如此。
> 在IE8或早期版本中，如果图片没有添加到DOM文档中了，则load事件发生时不会生成event对象。对未添加到文档中的<img\>元素以及image对象来说都是如此。
还有一些元素也以非标准的方式支持load事件。<script\>元素会在Javascript文件加载完成后触发load事件，从而可以动态监测。要下载JavaScript文件必须同时指定src属性，并添加到文档中。因此指定事件处理程序和指定src属性的顺序并不重要。
``` js
window.addEventListener('load', () => {
	const script = document.createElement('script')
	script.addEventListener('load', (event) => {
		console.log('loaded');
	})
	script.src = "./06-example.js"
	document.body.appendChild(script)
})
```
这里的event对象的target属性在大多数浏览器中是<scirpt\>节点。IE8及更早的版本的不支持<scirpt\>触发load事件。

IE和Opera支持<link\>元素触发load事件，因此支持动态检测样式表是否加载完成。同<script\>标签相同，在指定href属性，并添加到文档之前不会下载样式表(若是没有添加rel属性，也不会下载样式表)
``` js
window.addEventListener('load', () => {
	const link = document.createElement('link')
	link.type = "text/css"
	link.rel = "stylesheet"
	link.addEventListener('load', (event) => {
		console.log('outside css loaded');
	})
	link.href = './07-example.css'
	document.getElementsByTagName('head')[0].appendChild(link)
})
```
### unload事件
与load事件相对应的是unload事件，unload事件会在文档卸载完成后触发。unload事件一般是从一个页面导航到另一个页面时触发，最常用于清理引用，以免内存泄漏。 <--刷新就可以看到了，就一瞬间,但是发生页面跳转的时候，似乎是无法看到的。
``` js
window.addEventListener('unload', (event) => {
	console.log('Unloaded!');
})
```
第二种方式是通过给body添加onunload属性
``` js
<body onload="console.log('loaded')" onunload="console.log('body unload')">
```
无论以上哪种方式，在处理程序中，都不能使用页面加载后才有的对象，此时访问DOM或修改页面外观都会导致报错。<--不知道为啥无法使用window.open()
### resize事件
当浏览器窗口被缩放到新高度或宽度时，会触发resize事件。这个事件在window上触发，因此可以通过Javascript在window上，或者为body添加onresize属性来指定事件处理程序。
``` js
window.addEventListener('resize', (event) => {
	console.log('Resized');
})
```
类似于在其他window上发生的事件，此时会生成event对象，且这个对象的target属性时document。

最好不要在这个事件中执行过多计算，否则可能会由于执行过于频繁而导致浏览器相应变慢。
> 浏览器在最大化和最小化时也会触发resize事件。
### scroll事件
scroll事件发生window上，但实际上反映的是页面中相应元素的变化。混则模式下，可以通过<boody\>元素检测scrollLeft和scrollTop属性的变化。而在标准模式下，这些变化发生在<html\>上(除早期Safari以外)。下面的代码演示如何处理这些差异：
``` js
window.addEventListener('scroll', (event) => {
	if (document.compatMode == 'CSS1Compat') {
		console.log(document.documentElement.scrollTop);
	} else {
		console.log(document.body.scrollTop);
	}
})
```
## 焦点事件
焦点事件在页面元素获得或失去焦点时触发。这些事件可以与document.hasFoucus()和document.activeElement一起为开发者提供用户在页面中的导航的信息。焦点事件有以下6种：
+ blur：当元素失去焦点时触发。这个事件不冒泡，所有浏览器都支持
+ DOMFouchsIn:当元素获得焦点时触发。这个事件是focus的冒泡版。Opera是唯一支持这个事件的浏览器，DOM3 Events废弃了DOMFoucsIn。推荐focusin
+ DOMFoucsOut:当元素失去焦点触发。这个事件是blur的通用版。Opera是唯一支持这个事件的主流浏览器。DOM3 Event废弃了DOMFoucusOut，推荐focusout
+ focus:当元素获得焦点时触发。这个事件不冒泡，所有浏览器都支持。
+ focusin: 当元素获得焦点时触发。这个事件是focus的冒泡版。
+ focusout: 当元素失去焦点时触发。这个事件是blur的通用版。

焦点事件中的两个主要事件是focus和blur，这两个事件在Javascript早期就得到了浏览器的支持。但二者最大的问题是不冒泡。

当焦点从页面中的一个元素移到另一个元素上时，会依次发生如下事件。
1. focusout在失去焦点的元素上触发
2. focusin在获得焦点的元素上触发
3. blur在失去焦点的元素上触发
4. DOMFocusOut在失去焦点的元素上触发
5. focus在获得焦点的元素上触发
6. DOMFoucsIn在获得焦点的元素上触发

其中blur、DOMFoucsOut和focusout的事件目标是失去焦点的元素，而focus、DOMFocusIn和focusin的事件目标时获得焦点的元素。

在Edge(chormium)中 blur -> focusout -> DOMFocusOut -> focus -> focusin -> DOMFocusIn
## 鼠标和滚轮事件
鼠标事件是Web开发中最常用的一组事件.DOM3 Events定义了9种鼠标事件。
+ click: 在用户单击鼠标主键或按键盘回车键时触发。这主要是基于无障碍的考虑，让键盘和鼠标都可以触发onclick事件处理程序
+ dblclick：在用户双击鼠标主键时触发。
+ mousedown：在用户按下任意鼠标键时触发。这个事件不能通过键盘触发。
+ mouseenter：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。
+ mouseleave: 在用户把鼠标光标从内部移到元素外部触发。这个事件不冒泡,也不会在光标经过后代元素时触发.
+ mousemove: 在鼠标光标在元素上移动时反复触发。这个事件不能通过键盘触发.
+ mouseout: 在用户把鼠标光标从一个元素移到另一个元素上时触发。移到的元素可以是原始元素的外部元素，也可以是原始元素的子元素。这个事件不能通过键盘触发。
+ mouseup: 在用户释放鼠标键时触发。这个事件不能通过键盘触发。

页面中所有元素都支持鼠标事件。除了mouseenter和mouseleave，所有鼠标事件都会冒泡，都可以被取消，而这会影响浏览器的默认行为。

由于事件之间存在关系，因此取消鼠标事件的默认行为也会影响其他事件。

比如，click事件触发的前提是mousedown事件触发后，紧接着又在同一个元素上触发了mouseup事件。如果mousedown或mouseup中任意一个事件被取消了，那么click事件就不会触发。 类似的，两次click会导致dblckick事件触发。只要任何逻辑阻止了两个click事件，则dblclick事件就不会触发，以上四个事件永远会按照以下顺序触发：
1. mousedown
2. mouseup
3. click
4. mousedown
5. mouseup
6. click
7. dblclick

click和dblclick在触发前都依赖其他事件触发，而mouedown和mouseup则不会受其他事件影响。

IE8及更早版本的实现中有个问题，这会导致双击事件跳过第二次mousedown和click事件。相应顺序变成了：
1. mousedown
2. mouseup
3. clcik
4. mouseup
5. dblclick

鼠标事件在DOM3 Events中对应的类型是"MouseEvent",而不是"MouseEvents"

鼠标事件上还有一个名为滚轮事件的子类别。滚轮事件只有一个事件mousewheel，反映的是鼠标滚轮或带滚轮的类似设备上滚轮的互动。

### 客户端坐标
鼠标事件都是在浏览器视口中的某个位置上发生的。着写信息被保存在event对象的clentX和clientY属性中。这两个属性表示事件发生时鼠标光标在视口中的坐标。客户端坐标不考虑页面滚动，这两个值并不代表鼠标在页面上的位置。
``` html
	<div id="myDiv"></div>
	<script>
		const myDiv = document.querySelector('#myDiv')
		myDiv.addEventListener('click', (event) => {
			console.log(`Client coordinates: ${event.clientX},${event.clientY}`);
		})
	</script>
```
### 页面坐标
通过pageX和pageY可以获取页面坐标。
``` js
myDiv.addEventListener('click', (event) => {
	console.log(`Page coordinates: ${event.pageX},${event.pageY}`);
})
```
IE及更早的版本没有在event对象上暴露页面坐标。不过可以通过客户端坐标和滚动信息计算出来
``` js
var myDiv = document.querySelector('#myDiv')
myDiv.addEventListener('click', function (event) {
	var pageX = event.pageX,
		pageY = event.pageY
	if (pageX === undefined) {
		pageX = event.clientX + (document.body.scrollLeft || document.documentElement.scrollLeft)
	}
	if (pageY === undefined) {
		pageY = event.clientY + (document.body.scrollTop || document.documentElement.scrollTop)
	}
	console.log('Page coordinates: ' + pageX + ',' + pageY);
})
```
IE8以下要求还挺多
``` js
var myDiv = document.querySelector('#myDiv')
myDiv.addEventListener('click', function (event) {
	var pageX = event.pageX,
		pageY = event.pageY
	if (pageX === undefined) {
		pageX = event.clientX + (document.body.scrollLeft || document.documentElement.scrollLeft)
	}
	if (pageY === undefined) {
		pageY = event.clientY + (document.body.scrollTop || document.documentElement.scrollTop)
	}
	console.log('Page coordinates: ' + pageX + ',' + pageY);
})
```
### 屏幕坐标
鼠标事件不仅是在浏览器窗口中发生的，也是在整个屏幕上发生的。可以通过event对象的screeX和screenY属性获取鼠标光标在屏幕上的坐标。
``` js
var myDiv = document.querySelector('#myDiv')
myDiv.addEventListener('click', (event) => {
	console.log(`Screen coordinates: ${event.screenX}, ${event.screenY}`);
})
```
### 修饰键
虽然鼠标事件主要通过鼠标触发的，但有时候要确定用户想要实现的操作，还要考虑键盘按键的状态。键盘上的修饰符Shift,Ctrl,Alt和Meta经常用于修改鼠标事件的行为。DOM规定了4个属性来表示这几个修饰键的状态:shiftKey,ctrlKey,altKey和metaKey。这几个属性会在各自对应的修复符被按下时包含布尔值true,没有被按下时包含false。在鼠标事件发生时，可以通过这几个属性来检测修饰符是否被按下。如下例子，在click事件发生时检测每个修饰符的状态：
``` html
	<div id="myDiv2"></div>
	<script>
		let div = document.querySelector('#myDiv2')
		div.addEventListener('click', (event) => {
			const keys = new Array()
			if (event.shiftKey) {
				keys.push('shift')
			}
			if (event.ctrlKey) {
				keys.push('ctrl')
			}
			if (event.altKey) {
				keys.push('alt')
			}
			if (event.metaKey) {
				keys.push('meta')
			}
			console.log("Keys:" + keys.join(', '));
		})
	</script>
```
> 现代浏览器支持所有者4个修饰符。IE8及更早版本不支持metaKey属性。
### 相关元素
对mouseover和mouseout事件而言，还存在与事件相关的其他元素。这两个事件都涉及从一个元素的边界之内把光标移到另一个元素的边界之内。对mouseover事件来说，事件的主要目标是获得贯标的元素，相关元素是失去光标的元素，类似的，对mouseout事件来说，事件的主要目标是失去光标的元素，而相关元素是获得光标的元素。如下
``` html
<body>
	<div id="myDiv3"></div>
</body>
```
若是从div移出，div会触发mouseout事件，相关元素是body。 而body触发mouseover事件。相关元素<div\>。

DOM通过event对象的relatedTarget属性提供了相关元素的信息。 这个属性只有在mouseover和mouseout事件发生才包含值。其他所有事件的这个属性的值都是null。 IE8及更早版本不支持relatedTarget属性，但还提供了其他可以的可以访问到相关元素的属性。在mouseover事件触发时，IE会提供fromElement属性，其中包含相关元素。而在mouseout事件触发时，IE会提供toElement属性，其中包含相关元素。
``` html
  <!-- 当从myDiv3移到myDiv4时 -->
	<div id="myDiv3"></div>
	<div id="myDiv4"></div>
	<script>
		const div3 = document.querySelector('#myDiv3')
		const div4 = document.querySelector('#myDiv4')
		div3.addEventListener('mouseout', (event) => {
			console.log(event.relatedTarget); // div#myDiv3
		})
		div4.addEventListener('mouseover', (event) => {
			console.log(event.relatedTarget); // div#myDiv3
		})
	</script>
```
### 鼠标按键
只有在元素上单击鼠标主键(或按下键盘上的回车键)时click事件才会触发。因此按键信息并不是必须的。对mousedown和mouseup事件来说，event对象上会有一个button属性，表示按下后释放的是哪个按键。DOM为这个button属性定义3个值:0表示鼠标主键，1表示鼠标中键，2表示鼠标副键。

IE8及更早版本也提供了button属性，但这个属性的值与前面说的完全不同：
+ 0，表示没有按下任何键；
+ 1，表示按下鼠标主键；
+ 2，表示按下鼠标副键；
+ 3，表示同时按下鼠标主键、副键；
+ 4，表示按下鼠标中键；
+ 5，表示同时按下鼠标主键和中键；
+ 6，表示同时按下鼠标副键和中键；
+ 7，表示同时按下3个键
> 主流浏览器以DOM为准只有IE8版本不同。
### 额外事件
DOM2 Events规范在event对象上提供了detail属性，以给出事件的更多信息。 对鼠标事件来说，detail包含一个数值，表示在给定位置上发生了多少单击。单击相当于在同一个像素上发生一次mousedown紧跟一次mouseup。detail的值从1开始，每次单击会加1.如果鼠标在mousedown和mouseup之间移动了，则detail会重置为0.

IE还为每个鼠标事件提供了以下额外信息：
+ altLeft,布尔值，表示是否按下做alt键(altLeft时true，那么altKey也是true)
+ ctrlLeft,布尔值，表示是否按下左Ctrl键(如果ctrlLeft是true，那么ctrlKey也是true)
+ offsetX, 光标相对于目标元素边界的x坐标
+ offsetY, 光标相对于目标元素边界的y坐标
+ shiftLeft，布尔值，表示是否按下了左Shift键(如果shiftLeft是true，那么shiftKey也是true)

这些属性的作用有限，这是因为只有IE支持。而且，它们提供的信息要么没必要，要么可以通过其他方式计算。
### mousewheel事件
mousewheel事件会在用户使用鼠标滚轮时触发，包括在垂直反向上任意滚动。 这个事件会在任何元素上触发，并冒泡到document(IE8)和window(现代浏览器),mousewheel事件的event对象包含鼠标事件的所有标准信息，此外还有一个名为wheelDelta的信属性。当鼠标滚轮向前滚动时，whellDelta每次都是+120;而当鼠标滚轮向后移动时,wheelDelta每次都是-120(edge 150)

可以为页面上的任何元素或文档田家庵onmousewheel事件处理程序，以处理所有鼠标滚轮交互，比如：
``` js
document.documentElement.addEventListener('mousewheel', (event) => {
	console.log(event.wheelDelta); // 150?
})
```
### 触摸屏设备
IOS和Android等触屏设备的实现大相径庭，因为触摸屏不支持鼠标操作。在位触摸屏设备开发时，要记住以下事项。
+ 不支持dblclick事件。双击浏览器窗口可以方法，当没有办法覆盖这个行为。
+ 单指点触屏幕上的可点击会触发mousemove事件。如果操作会导致内容变化，则不会再触发其他事件。如果屏幕上没有变化，则会相继触发mousedown，mouseup和click事件。点触不可点击的元素不会触发事件。可点击元素是指点击时有默认动作的元素(如链接)或指定了onclick事件处理程序的元素。
+ mousemove事件也会触发mouseover和mouseout事件。
+ 双指点触屏幕并滑动导致页面滚动会触发mousewheel和scroll事件。
### 无障碍问题
如果Web应用或网站必须考虑残障人士，特别是使用屏幕阅读器的用户，那么必须小心使用鼠标事件。如前所述，按回车键可以触发click事件，但其他鼠标事件不能通过键盘触发。因此建议不要使用click事件之外的其他鼠标事件向用户提示功能或触发代码执行，这是因为其他鼠标事件会严格妨碍盲人或视障用户使用。下面是几条使用鼠标事件时应该遵循的无障碍建议。
+ 使用click事件执行代码。使用onmousedown执行代码时，程序会运行的更快，但在屏幕阅读器上，这样会导致代码无法执行，这是因为屏幕阅读器无法触发mousedown事件。
+ 不要使用mouseover向用户显示新选项。同样，原因是屏幕阅读器无法触发mouseover。若是必须通过该方式显示新选项，那么可考虑像是相同信息的键盘快捷键。
+ 不用使用dblclick执行重要的操作，这是因为键盘不能触发这个事件。
## 键盘于输入事件
键盘事件是用户操作键盘触发的，DOM2 Events最初定义了键盘事件，但该规范在最终发布前删除了相应内容。因此，键盘事件很大程度是基于原始的DOM0实现的。

DOM3 Events位键盘事件提供了一个首先在IE 9完全实现的规范。

键盘事件包含3个事件：
+ keydown, 用户按下键盘上某个键触发，而且持续按住会重复触发。
+ keypress, 用户按下键盘下某个键并产生字符时触发，而且持续按住会重复触发。Esc键也会触发这个事件。DOM3 Events废弃了key press事件，而推荐textInput事件。
+ keyup, 用户释放键盘上某个键时触发。

虽然所有元素都支持这些事件，但当用户在文本框中输入内容时最容易看到。

输入事件只有一个，即textInput。这个事件对keypress事件的扩展，用于在文本显示给用户之前更方便地截取文本输入。textInput会在文本插入文本框之前触发。

当用户按下键盘上地某个字符键时，首先会触发keypress事件，最后触发keyup事件。这里地keydown和keypress事件会在文本框出现变化之前触发，而keyup事件会在文本框出现变化之后触发。如果一个字符键被按住不放，keydown和keypress就会反复触发，知道这个键被释放。

对于非字符键，在键盘上按一下这个键，会先触发keydown事件，然后触发keyup事件。如果按住某个非字符键不放，则会重复触发keydown事件，知道这个键被释放，此时会触发keyup事件。
> 键盘事件支持与鼠标事件相同地修饰键。shiftKey，ctrlKey，altKey和metaKey属性在键盘事件中都是可用地。 IE8及更早的版本不支持metaKey属性
### 键码
对于keydown和keyup事件，event对象的keyCode属性中会保存一个键码，对应键盘上特定的一个键。对于字母和数字键，keyCode的值与小写字母和数字的ASCII编码一致。比如数字7键的keyCode为55，而在字母A键的keyCode为65，而且跟是否按shift键无关。DOM和IE的event对象都支持keyCode属性。下面这里例子展示了如何使用keyCode属性：
``` js
<textarea name="myText" id="myText" cols="30" rows="10"></textarea>
<script>
	const textbox = document.getElementById('myText')
	textbox.addEventListener('keyup', (event) => {
		console.log(event.keyCode);
	})
</script>
```
下表给出了键盘上所有非字符键的键码。
![](index_files/20-3.png)
### 字符编码
在keypress事件发生时，意味着按键会影响屏幕上显示的文本。对插入或移除字符的键，所有浏览器都会触发keypress事件，其他键则取决于浏览器。因为DOM3 Events规范才刚刚开始，所以不同浏览器之间的实现存在差异。

浏览器在event对象上支持charCode属性，只有发生keypress事件时这个属性才会被设置值，包含的是按键字符对应的ASCII编码。通常，charCode属性的值是0，在keypress事件发生时则是对应按键的键码。只要获取到keyCode值，则可以使用String.fromCharCode()方法转换为实际的字符。
``` js
var EventUtil = {
	getCharCode: function (event) {
		if (typeof event.charcode == "number") {
			return event.charcode
		} else {
			return event.keyCode
		}
	}
}
textbox.addEventListener('keypress', (event) => {
	const charCode = EventUtil.getCharCode(event)
	const key = String.fromCharCode(charCode)
	console.log(key);
})
```
### DOM3 的变化
DOM3规范并未规定charCode属性，而是定义了key和code两个新属性。

其中key属性用于代替keyCode，且包含字符串。在按下字符串时，key的值等于文本字符(如'k'或'M')；在按下非字符串时，key的值是键名(如"Shift"或"ArrowDown")。char属性在按下字符键时与key类似，在按下非字符键时为null。

IE支持key属性但不支持char属性。Safari和Chorme支持keyIdentifier属性，在按下非字符键时返回与key一样的值。对于字符键，keyIdentifier返回以"U+0000"形式表示的Unicode值的字符串形式的字符编码。<-- 我这个版本的edge似乎没有这个属性。。
``` html
	<input type="text" id="input1">
	<script>
		const input1 = document.getElementById('input1')
		input1.addEventListener('keypress', (event) => {
			const identifier = event.key;
			if (identifier) {
				console.log(identifier);
			}
		})
	</script>
```
由于缺乏跨浏览器支持，因此不建议使用key，keyIdentifier，和char