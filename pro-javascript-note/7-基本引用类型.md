# 对象
+ 对象：某个引用类型的实例. 
+ 引用类型：也被称为对象定义,描述对象应该有的属性和方法。
# Date
Date类型将日期保存为UTC(Universal Time Coordinated),从1970年1月1日至今所经过的毫秒数。

创建日期对象
``` js
let now = new Date()
```
## Date.parse()
转换为毫秒数,Date.parse,接受格式.若是无法转换会返回NaN
``` js
let date = Date.parse('5 / 23 / 2019')
let date1 = Date.parse('May 23,2019')
let date2 = Date.parse('Tue May 23,2019 00:00:00 GMT-0700')
let date3 = Date.parse('2019-5-23 00:00:00')
```
new Date()
``` js
// new Date(),会自动调用Date.parse()
// 下面两段代码是等价的
let date = new Date('2020-6-5 ')
let date = new Date(Date.parse('2020-6-5'))
```
> 不同的Date类型，在某些Date的处理不一样，如参数为越界日期时，不同函数的处理就不同。
## Date.UTC() 
类似parse，但是参数表示方法是不不同的.其中月(0-11)和时(0-23)
``` js
let date = new Date(Date.UTC(2020, 6, 5, 10, 10, 30))
console.log(date); //2020-07-05T10:10:30.000
```
Date.UTC也会被new Date(),隐式调用，不过隐式调用时创建的是本地日期(本时区，而不是GMT日期)
## Date.now()
返回执行时间的毫秒数，可以很方便的计算函数执行时间
``` js
let s = Date.now()
doSomething()
let e = Date.now()
console.log(e - s); 
```
## 继承的方法
``` js
let date = new Date('2019-2-1')
console.log(date.toLocaleString()); //2019/2/1 上午12:00:00 本地环境一致的日期和时间,不带时区信息
console.log(date.toString());//Fri Feb 01 2019 00:00:00 GMT+0800 (中国标准时间)  带时区信息
console.log(date.valueOf()); //1548950400000 返回日期的毫秒数
```
## 日期格式化方法
``` js
let date = new Date('2019-2-1')
console.log(date.toDateString()); //Fri Feb 01 2019
console.log(date.toUTCString()); //Thu, 31 Jan 2019 16:00:00 GMT
// ...
```
# RegExp
## 表示
``` js
let expresion  = /pattern/flags
```
flags:
+ g:全局模式
+ i：不去分大小写
+ m:多行模式
+ y：黏附模式，只查找lastIndex开始之后的字符串
+ u：Unicode模式?
+ s：dotAll模式，表示元字符，匹配任何字符？

在模式中，所有元字符都需要进行转义。转义符 \
## RegExp构造函数
使用构造函数，普通的字符串没有太大区别，但是一些元字符，需要进行二次转义。如:
+ \n 需要表示为 \\n
+ \\ 则需要表示愿 \\\\
## RegExp的实例属性
通过RegExp可以了解正则表达式的信息，但一般不常用，因为声明就可以直接看清楚了
``` js
let pattern = /\[bc\]at/gi
console.log(pattern.global);  //true 是全局模式
console.log(pattern.ignoreCase); // true 忽略大小写匹配
console.log(pattern.multiline); // false 不是多行模式
console.log(pattern.lastIndex); // 0 下一次搜索的开始位置是0
console.log(pattern.source); // \[bc\]at 正则表达式的字面量字符串
console.log(pattern.flags); // gi 
```
## RegExp的实例方法
### exec()
matches是数组，第一个元素匹配整个模式的字符串，其他元素是与表达式中的匹配的字符串。
``` js
let text = 'mon and dad and baby'
let pattern = /mon (and dad (and baby)?)?/gi
let matches = pattern.exec(text)
console.log(matches.index); //0 字符串中匹配模式的起始位置
console.log(matches.input); //'mon and dad and baby'
console.log(matches[0]); // 'mon and dad and baby'
console.log(matches[1]); // 'and dad and baby'
console.log(matches[2]); // 'and baby'
```
如果没有设置global，则exex(),每次的index都是从0开始的,二设置了则会向前搜索下一个匹配项
### test()
只测试模式是否匹配
``` js
let text = "000-00-0000"
let pattern = /\d{3}-\d{2}-\d{4}/
console.log(pattern.test(text)); //true
```
## 继承的方法
``` js
let pattern = new RegExp('\\[dat\\]', 'gi')
// 下面三者都是返回   /\[dat\]/gi
console.log(pattern.toString()); // 返回正则字面量形式
console.log(pattern.toLocaleString()); //字面量形式
console.log(pattern.valueOf()); //返回正则表达式本身,和字面量形式有什么区别嘛
```
## RegExp构造属性
RegExp构造函数本身有几个属性,适用于作用域内所有正则表达式。 有简写,但是简写可不大好记呢
``` js
let text = 'this has been a short summer'
let pattern = /(.)een/
if (pattern.test(text)) {
  // 输入，左边文本，右边文本，最后匹配，最后匹配的捕获组
  console.log(RegExp.input, RegExp['$_']); // this has been a short summer
  console.log(RegExp.leftContext, RegExp['$`']); // this has 
  console.log(RegExp.rightContext, RegExp["$'"]); //  a short summer
  console.log(RegExp.lastMatch, RegExp["$&"]); // been
  console.log(RegExp.lastParen, RegExp["$+"]); // b
}
```
RegExp可以使用RegExp$1~RegExp$9来访问，最多9个捕获组。
> RegExp的所有属性因为没有Web标准,因此不要再生产环境中使用
# 原始值包装类型
当用到某个原始值的方法或属性是，后台都会创建一个相应原始包装类型的对象。
``` js
let s1 = 'some text'
let s2 = s1.substring(2)
```
s1逻辑上是没有方法的，但以读模式访问字符串的任何时候，后台会执行以下三步：
1. 创建一个String类型的实例
2. 调用实例上的特定方法
3. 销毁实例
``` js
// 上面三步的后台执行过程
let s1 = new String('some text')
let s2 = s1.substring(2)
s1 = null
```
原始值包装类型和引用类型(直接new)的区别主要是生命周期，原始值包装类型只存在与在其那段代码执行期间,而直接new则存在与其所在作用域

可以显示使用Boolean，Number，String原始值包装对象，但应该在确实必要的时候做
``` js
// 存在混淆问题
let s1 = 'some text'
let s2 = new String('some text')
console.log(typeof s1); // string
console.log(typeof s2); // object
```
使用new调用包装类型的构造函数，与调用同名的转型函数是不一样的
``` js
// 与转型函数的区别
let value = '25'
let number = Number(value)
console.log(typeof number); // number
let obj = new Number(value)
console.log(typeof obj); // object
```
Object构造函数，会根据传入值的类型返回相应原始包装的实例
``` js
let obj = new Object('29')
console.log(obj instanceof String); // true
console.log(obj instanceof Number); // flase
```
## Boolean
Boolean实例会重现valueOf()、toLocaleString()和toString(),返回原始值或者字符串的ture，false。但是因为实例仍是对象，在进行布尔表达式时会出现与预期相悖的结果
``` js
let falseObj = new Boolean(false)
let res = falseObj && true
console.log(res); // true
```
> 强烈建议永远不要使用Boolean() ヾ(≧▽≦*)o
## Number
同Boolean一样，重写了valueOf(),toLocaleString(),toString()。其中toString()方法接受一个表示基数的参数。
``` js
let num = 31
console.log(num.toString()) // 31
console.log(num.toString(2)); // 11111
console.log(num.toString(8)); // 37
console.log(num.toString(10)); // 31
console.log(num.toString(16)); // 1f
console.log(num.toString(32)); // v
```
### toFixed()
格式化方法,显示后面的小数位,toFixed会自动舍入
``` js
let num = 10
console.log(num.toFixed(2)); //10.00

let num = 0.1 + 0.2 // 0.30000000000000004
console.log(num.toFixed(2)); // 0.3
```
### toExponential()
格式化方法，科学计数法表示，参数为结果中的小数位数
``` js
let num = 10
console.log(num.toExponential(2)); //1.00e+1
```
### toPrecision()
根据情况返回最合理的输出，后面参数一般为0~21
``` js
let num = 99
console.log(num.toPrecision(1)); // 1e+2 100因为99无法一位表示
console.log(num.toPrecision(2)); // 99
console.log(num.toPrecision(3)); // 99.0
```
### isInteger()
isInterger() ES6新增,用于辨别一个数是否保存在整数
``` js
console.log(Number.isInteger(1)); //true
console.log(Number.isInteger(1.00)); //true
console.log(Number.isInteger(1.01)); //fasle
console.log(Number.isInteger(1.01e+2)); //fasle
```
### isSafeInterger()
整数有一个安全范围$-2^{53}+1$~$2^{ 53 } -1$,超过这个范围的整数，无法正确表示。isSafeInterger()判断一个数是不是在安全范围内。
``` js
let num = (2 ** 53)
console.log(Number.isSafeInteger(-num)); //false
console.log(Number.isSafeInteger(-num + 1)); // true
console.log(Number.isSafeInteger(num)); //fasle
console.log(Number.isSafeInteger(num - 1)); //true
```
## String()