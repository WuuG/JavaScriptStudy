# 1.生成器
生成器是一个特殊的函数,用于异步编程
异步编程 其他解决方案 使用纯回调函数
总感觉这个解决异步编程十分麻烦
``` javascript
  function* gen() {
    //yield 分隔符，将代码分成四块，迭代调用
    console.log("hello generator");
    yield "啥意思？";
    console.log(222);
    yield "什么用？";
    console.log(333);
    yield "函数代码的分隔符?";
    console.log(444);
  }
  let iterator = gen();
  console.log(iterator);
  // next()函数会运行到yield为止，yield相对与这个代码块的return
  iterator.next();
  iterator.next();
  //这里如果用上面的 iterator是输出空的，iterator已经到结尾了
  for (v of gen()) {
    console.log(v);
  }
```
## 生成器的函数参数
``` javascript
  function* gen(...arg) {
    console.log(arg);
    //第二next所传入的参数，会在第一次yield返回后，将yield作为下个代码块的参数。
    const yield1 = yield 111;
    console.log(yield1);
    yield 222;
    const yield4 = yield 333;
    console.log(yield4);
  }
  let iterator = gen("AAA");
  //那第一个next所传入的参数呢?
  console.log(iterator.next("ANAN"));
  //next 方法也是可以传入实参的
  console.log(iterator.next("BBB"));
  console.log(iterator.next());
  console.log(iterator.next("DDD"));
```
## 异步编程
1. 第一个生成器函数实例
``` javascript
function printByTime(delay) {
  setTimeout(() => {
    console.log(delay);
    iterator.next();
  }, delay);
}
function* gen() {
  yield printByTime(1000);
  yield printByTime(2000);
  yield printByTime(3000);
}
//这里需要用iterator接受，为了实现是在同一个迭代器运行
const iterator = gen();
iterator.next();
```
2. 第二个生成器函数实例
``` javascript 
function getUsers() {
  setTimeout(() => {
    let data = "用户数据";
    iterator.next(data);
  }, 1000);
}
function getOrders() {
  setTimeout(() => {
    let data = "订单数据";
    iterator.next(data);
  }, 1000);
}
function getGoods() {
  setTimeout(() => {
    let data = "商品数据";
    iterator.next(data);
  }, 1000);
}
function* gen() {
  let users = yield getUsers();
  console.log(users);
  let orders = yield getOrders();
  console.log(orders);
  let Goods = yield getGoods();
  console.log(Goods);
}
let iterator = gen();
iterator.next();
```
